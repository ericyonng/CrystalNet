# 导表工具设计

* 读取所有配置表数据

* 读取表头信息

* 分类客户端和服务端字段

* 若表内没有导出客户端也没有导出服务端的不需要解析

* 字段名校验（首字母必须是英文或者下划线）不能是关键字等已有的名字

* 数据类型校验必须是规定的数据类型（bool, int8, uint8, int16, uint16, int32, uint32, int64, uint64, string, array[...], dict<..., ...>, hash_dict<..., ...>）

* 校验 check_index(with_table_field(...)), check_index(with_check(...)), check_index(with_equal(...)), check_index(with_...)

  check_key(...)/check_value(...) 针对dict类型

  check_not_empty() 非空校验

* 校验运算之间用|分隔开，但是它们是且的关系

* flags: unique:唯一值, index，索引会创建unordered_dict/dict的key映射的配置

* 默认值：为空的时候初始化的值（会有一个NullDefaultValue, 会根据不同的数据类型返回不同的空的默认值，比如int等的返回值是0， string是"", dict就返回空的dict等）

* 描述信息：会生成字段的注释一部分

* 导表还会在.h上生成必要的表名，文件名（带路径的）,类名信息，后面注释添加的额外信息，由于编译成二进制程序后不支持utf8所以应该写在一个文本中，然后读取替代

  ```c++
  // Config:
  /*
  * FileName:
  * SheetName:
  * TypeName:
  * Time: 2023.02.19 xx:xx:xx
  * Brief:
  * x 行 * y 列
  * Generate By ConfigExporter Dont Modify!!!
  */
  
  #pragma once
  
  class XXXConfig
  {
  public:
  	Int32 _Id = DefaultValue;    // Id: id （注释必须有原始字段名名称 + 描述信息）
  	Int32 _Type = DefaultValue;	// Type: 类型:1, 2, 3 （注释必须有原始字段名名称 + 描述信息）
  };
  
  // ConfigMgr
  /*
  * FileName:
  * SheetName:
  * TypeName:
  * Time: 2023.02.19 xx:xx:xx
  * Brief:
  * Generate By ConfigExporter Dont Modify!!!
  */
  
  #pragma once
  
  class XXXConfigMgr
  {
  public:
  	const std::vector<XXXConfig *> &GetAllConfigs() const;
  	
  	const std::unordered_map<Int32, XXXConfig *> &GetIdRefConfigHashMap() const;
  	const std::map<Int32, XXXConfig *> &GetIdRefConfigMap() const;
  	const XXXConfig *GetConfigById(Int32 id) const;
  	
  	const std::unordered_map<Int32, std::vector<XXXConfig *>> &GetTypeRefConfigsHashMap() const;
  	const std::map<Int32, std::vector<XXXConfig *>> &GetTypeRefConfigsMap() const;
  	const std::vector<XXXConfig *> &GetConfigsByType(Int32 type) const;
      
      bool Load();
  	
  private:
  	std::vector<XXXConfig *> _configs;
  	
  	// unique id => config
  	std::unordered_map<Int32, XXXConfig *> _idRefConfigHashMap;  // id => config
  	std::map<Int32, XXXConfig *> _idRefConfigMap;    // id => config
  	
  	// index type => configs
  	std::unordered_map<Int32, std::vector<XXXConfig *>> _typeRefConfigsHashMap;
  	std::map<Int32, std::vector<XXXConfig *>> _typeRefConfigsMap;
  
  };
  ```

  