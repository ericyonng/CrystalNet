/*!
*  MIT License
*  
*  Copyright (c) 2020 ericyonng<120453674@qq.com>
*  
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the "Software"), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*  
*  The above copyright notice and this permission notice shall be included in all
*  copies or substantial portions of the Software.
*  
*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*  SOFTWARE.
* 
* Author: Eric Yonng
* Description: Generated By protogentool, Dont Modify This File!!!
*/


#include "pch.h"
#include <protocols/cplusplus/library/com_library.pb.h>
#include <protocols/orm_out/BorrowOrderInfoOrmData.h>
#include <protocols/orm_out/BorrowBookInfoOrmData.h>
#include <protocols/cplusplus/library/com_library.pb.h>
#include <protocols/orm_out/CancelOrderReasonOrmData.h>
#include <protocols/cplusplus/library/com_library.pb.h>

SERVICE_COMMON_BEGIN

POOL_CREATE_OBJ_DEFAULT_IMPL(BorrowOrderInfoOrmData);

BorrowOrderInfoOrmData::BorrowOrderInfoOrmData()
:_ormRawPbData(new ::CRYSTAL_NET::service::BorrowOrderInfo)
{
}

BorrowOrderInfoOrmData::BorrowOrderInfoOrmData(::CRYSTAL_NET::service::BorrowOrderInfo *pb)
:_ormRawPbData(NULL)
{
    AttachPb(pb);
}

BorrowOrderInfoOrmData::BorrowOrderInfoOrmData(const BorrowOrderInfoOrmData &other)
:IOrmData(reinterpret_cast<const IOrmData &>(other))
,_ormRawPbData(other._ormRawPbData ? new ::CRYSTAL_NET::service::BorrowOrderInfo(*other._ormRawPbData) : NULL)
{
    {
        const auto count = _ormRawPbData->borrowbooklist_size();

        _borrowbooklist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _borrowbooklist[idx] = SERVICE_COMMON_NS::BorrowBookInfoOrmData::NewThreadLocal_BorrowBookInfoOrmData(_ormRawPbData->mutable_borrowbooklist(idx));

        _borrowbooklist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::BorrowBookInfoOrmData::DeleteThreadLocal_BorrowBookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BorrowBookInfoOrmData>(ptr));
        }) ;

        _borrowbooklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    if(_cancelreason)
        _cancelreason.Release();

    if(_ormRawPbData->has_cancelreason())
    {
        _cancelreason = SERVICE_COMMON_NS::CancelOrderReasonOrmData::NewThreadLocal_CancelOrderReasonOrmData(_ormRawPbData->mutable_cancelreason());

        _cancelreason.SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::CancelOrderReasonOrmData::DeleteThreadLocal_CancelOrderReasonOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::CancelOrderReasonOrmData>(ptr));
        }) ;

        _cancelreason->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

    }

}

BorrowOrderInfoOrmData::BorrowOrderInfoOrmData(BorrowOrderInfoOrmData &&other)
:IOrmData(std::forward<IOrmData>(other))
,_ormRawPbData(other._ormRawPbData)
{
    other._ormRawPbData = NULL;
    _borrowbooklist = std::move(other._borrowbooklist);

    _cancelreason = std::move(other._cancelreason);

}

BorrowOrderInfoOrmData::BorrowOrderInfoOrmData(const ::CRYSTAL_NET::service::BorrowOrderInfo &pb)
:_ormRawPbData(new ::CRYSTAL_NET::service::BorrowOrderInfo(pb))
{
    {
        const auto count = _ormRawPbData->borrowbooklist_size();

        _borrowbooklist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _borrowbooklist[idx] = SERVICE_COMMON_NS::BorrowBookInfoOrmData::NewThreadLocal_BorrowBookInfoOrmData(_ormRawPbData->mutable_borrowbooklist(idx));

        _borrowbooklist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::BorrowBookInfoOrmData::DeleteThreadLocal_BorrowBookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BorrowBookInfoOrmData>(ptr));
        }) ;

        _borrowbooklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    if(_cancelreason)
        _cancelreason.Release();

    if(_ormRawPbData->has_cancelreason())
    {
        _cancelreason = SERVICE_COMMON_NS::CancelOrderReasonOrmData::NewThreadLocal_CancelOrderReasonOrmData(_ormRawPbData->mutable_cancelreason());

        _cancelreason.SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::CancelOrderReasonOrmData::DeleteThreadLocal_CancelOrderReasonOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::CancelOrderReasonOrmData>(ptr));
        }) ;

        _cancelreason->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

    }


}

BorrowOrderInfoOrmData::~BorrowOrderInfoOrmData()
{
    if(LIKELY(!IsAttachPb()))
        CRYSTAL_RELEASE_SAFE(_ormRawPbData);
}

void BorrowOrderInfoOrmData::Release()
{
    BorrowOrderInfoOrmData::DeleteThreadLocal_BorrowOrderInfoOrmData(this);
}

BorrowOrderInfoOrmData &BorrowOrderInfoOrmData::operator =(const ::CRYSTAL_NET::service::BorrowOrderInfo &pb)
{
    CRYSTAL_RELEASE_SAFE(_ormRawPbData);
    _ormRawPbData = new ::CRYSTAL_NET::service::BorrowOrderInfo(pb);
    {
        const auto count = _ormRawPbData->borrowbooklist_size();

        _borrowbooklist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _borrowbooklist[idx] = SERVICE_COMMON_NS::BorrowBookInfoOrmData::NewThreadLocal_BorrowBookInfoOrmData(_ormRawPbData->mutable_borrowbooklist(idx));

        _borrowbooklist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::BorrowBookInfoOrmData::DeleteThreadLocal_BorrowBookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BorrowBookInfoOrmData>(ptr));
        }) ;

        _borrowbooklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    if(_cancelreason)
        _cancelreason.Release();

    if(_ormRawPbData->has_cancelreason())
    {
        _cancelreason = SERVICE_COMMON_NS::CancelOrderReasonOrmData::NewThreadLocal_CancelOrderReasonOrmData(_ormRawPbData->mutable_cancelreason());

        _cancelreason.SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::CancelOrderReasonOrmData::DeleteThreadLocal_CancelOrderReasonOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::CancelOrderReasonOrmData>(ptr));
        }) ;

        _cancelreason->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

    }

    _MaskDirty(true);
    return *this;
}

BorrowOrderInfoOrmData &BorrowOrderInfoOrmData::operator =(const BorrowOrderInfoOrmData &other)
{
    if(this == &other)
        return *this;

    IOrmData::operator =(reinterpret_cast<const IOrmData &>(other));
    CRYSTAL_RELEASE_SAFE(_ormRawPbData);
    if(other._ormRawPbData)
        _ormRawPbData = new ::CRYSTAL_NET::service::BorrowOrderInfo(*other._ormRawPbData);
    if(_ormRawPbData)
    {
            {
                const auto count = _ormRawPbData->borrowbooklist_size();
        
                _borrowbooklist.resize(count);
        
                for(Int32 idx = 0; idx < count; ++idx)
                {
                _borrowbooklist[idx] = SERVICE_COMMON_NS::BorrowBookInfoOrmData::NewThreadLocal_BorrowBookInfoOrmData(_ormRawPbData->mutable_borrowbooklist(idx));
        
                _borrowbooklist[idx].SetClosureDelegate([](void *ptr){
                    SERVICE_COMMON_NS::BorrowBookInfoOrmData::DeleteThreadLocal_BorrowBookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BorrowBookInfoOrmData>(ptr));
                }) ;
        
                _borrowbooklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                    _MaskDirty(true);
                }) ;
        
                }
            }
        
        
            if(_cancelreason)
                _cancelreason.Release();
        
            if(_ormRawPbData->has_cancelreason())
            {
                _cancelreason = SERVICE_COMMON_NS::CancelOrderReasonOrmData::NewThreadLocal_CancelOrderReasonOrmData(_ormRawPbData->mutable_cancelreason());
        
                _cancelreason.SetClosureDelegate([](void *ptr){
                    SERVICE_COMMON_NS::CancelOrderReasonOrmData::DeleteThreadLocal_CancelOrderReasonOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::CancelOrderReasonOrmData>(ptr));
                }) ;
        
                _cancelreason->SetMaskDirtyCallback([this](IOrmData *ptr){
                    _MaskDirty(true);
                }) ;
        
            }
        
    }
    _MaskDirty(true);

    return *this;
}

BorrowOrderInfoOrmData &BorrowOrderInfoOrmData::operator =(BorrowOrderInfoOrmData &&other)
{
    if(this == &other)
        return *this;

    IOrmData::operator =(std::forward<IOrmData>(other));
    _ormRawPbData = other._ormRawPbData;
    other._ormRawPbData = NULL;

    _borrowbooklist = std::move(other._borrowbooklist);

    _cancelreason = std::move(other._cancelreason);


    return *this;
}

void BorrowOrderInfoOrmData::Clear()
{
    _borrowbooklist.clear();

    _cancelreason.Release();


    if(_ormRawPbData)
        _ormRawPbData->Clear();

    _MaskDirty(true);
}

void BorrowOrderInfoOrmData::_AttachPb(void *pb)
{
    if(LIKELY(!IsAttachPb()))
        CRYSTAL_RELEASE_SAFE(_ormRawPbData);

    _ormRawPbData = reinterpret_cast<::CRYSTAL_NET::service::BorrowOrderInfo *>(pb);

    {
        const auto count = _ormRawPbData->borrowbooklist_size();

        _borrowbooklist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _borrowbooklist[idx] = SERVICE_COMMON_NS::BorrowBookInfoOrmData::NewThreadLocal_BorrowBookInfoOrmData(_ormRawPbData->mutable_borrowbooklist(idx));

        _borrowbooklist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::BorrowBookInfoOrmData::DeleteThreadLocal_BorrowBookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BorrowBookInfoOrmData>(ptr));
        }) ;

        _borrowbooklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    if(_cancelreason)
        _cancelreason.Release();

    if(_ormRawPbData->has_cancelreason())
    {
        _cancelreason = SERVICE_COMMON_NS::CancelOrderReasonOrmData::NewThreadLocal_CancelOrderReasonOrmData(_ormRawPbData->mutable_cancelreason());

        _cancelreason.SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::CancelOrderReasonOrmData::DeleteThreadLocal_CancelOrderReasonOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::CancelOrderReasonOrmData>(ptr));
        }) ;

        _cancelreason->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

    }


}

KERNEL_NS::LibString BorrowOrderInfoOrmData::ToJsonString() const
{
    return _ormRawPbData->ToJsonString();
}

bool BorrowOrderInfoOrmData::ToJsonString(std::string *data) const
{
    return _ormRawPbData->ToJsonString(data);
}

bool BorrowOrderInfoOrmData::FromJsonString(const Byte8 *data, size_t len)
{
    const auto ret = _ormRawPbData->FromJsonString(data, len);
    if(ret)
    {
        {
            const auto count = _ormRawPbData->borrowbooklist_size();
    
            _borrowbooklist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _borrowbooklist[idx] = SERVICE_COMMON_NS::BorrowBookInfoOrmData::NewThreadLocal_BorrowBookInfoOrmData(_ormRawPbData->mutable_borrowbooklist(idx));
    
            _borrowbooklist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::BorrowBookInfoOrmData::DeleteThreadLocal_BorrowBookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BorrowBookInfoOrmData>(ptr));
            }) ;
    
            _borrowbooklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
        if(_cancelreason)
            _cancelreason.Release();
    
        if(_ormRawPbData->has_cancelreason())
        {
            _cancelreason = SERVICE_COMMON_NS::CancelOrderReasonOrmData::NewThreadLocal_CancelOrderReasonOrmData(_ormRawPbData->mutable_cancelreason());
    
            _cancelreason.SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::CancelOrderReasonOrmData::DeleteThreadLocal_CancelOrderReasonOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::CancelOrderReasonOrmData>(ptr));
            }) ;
    
            _cancelreason->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
        }
    
    }

    return ret;
}

const ::CRYSTAL_NET::service::BorrowOrderInfo *BorrowOrderInfoOrmData::GetPbRawData() const
{
    return _ormRawPbData;
}

void BorrowOrderInfoOrmData::clear_orderid()
{
    _ormRawPbData->clear_orderid();
    _MaskDirty(true);
}

uint64_t BorrowOrderInfoOrmData::orderid() const
{
    return _ormRawPbData->orderid();
}

void BorrowOrderInfoOrmData::set_orderid(uint64_t value)
{
    _ormRawPbData->set_orderid(value);
    _MaskDirty(true);
}

Int32 BorrowOrderInfoOrmData::borrowbooklist_size() const
{
    return _ormRawPbData->borrowbooklist_size();
}

KERNEL_NS::SmartPtr<BorrowBookInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &BorrowOrderInfoOrmData::mutable_borrowbooklist(Int32 idx)
{
    return _borrowbooklist[idx];
}

void BorrowOrderInfoOrmData::DeleteArray_borrowbooklist(Int32 idx, Int32 count)
{
    for(Int32 pos = idx + count - 1; pos >= idx; --pos)
    {
        _borrowbooklist.erase(_borrowbooklist.begin() + pos);
    }

    _ormRawPbData->mutable_borrowbooklist()->DeleteSubrange(idx, count);
    _MaskDirty(true);
}

const std::vector<KERNEL_NS::SmartPtr<BorrowBookInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete>> &BorrowOrderInfoOrmData::borrowbooklist_OrmDataArray() const
{
    return _borrowbooklist;
}

const ::google::protobuf::RepeatedPtrField<::CRYSTAL_NET::service::BorrowBookInfo> &BorrowOrderInfoOrmData::borrowbooklist() const
{
    return _ormRawPbData->borrowbooklist();
}

const KERNEL_NS::SmartPtr<BorrowBookInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &BorrowOrderInfoOrmData::borrowbooklist_OrmDataArray(Int32 idx) const
{
    return _borrowbooklist[idx];
}

const ::CRYSTAL_NET::service::BorrowBookInfo &BorrowOrderInfoOrmData::borrowbooklist(Int32 idx) const
{
    return _ormRawPbData->borrowbooklist(idx);
}

KERNEL_NS::SmartPtr<BorrowBookInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &BorrowOrderInfoOrmData::add_borrowbooklist()
{
    auto newPb = _ormRawPbData->add_borrowbooklist();
    _borrowbooklist.push_back(KERNEL_NS::SmartPtr<BorrowBookInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete>());
    auto &elem = _borrowbooklist.back();
        elem = SERVICE_COMMON_NS::BorrowBookInfoOrmData::NewThreadLocal_BorrowBookInfoOrmData(newPb);

        elem.SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::BorrowBookInfoOrmData::DeleteThreadLocal_BorrowBookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BorrowBookInfoOrmData>(ptr));
        }) ;

        elem->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

    _MaskDirty(true);
    return elem;
}

void BorrowOrderInfoOrmData::clear_borrowbooklist()
{
    _ormRawPbData->clear_borrowbooklist();
    _borrowbooklist.clear();
    _MaskDirty(true);
}

void BorrowOrderInfoOrmData::clear_createordertime()
{
    _ormRawPbData->clear_createordertime();
    _MaskDirty(true);
}

uint64_t BorrowOrderInfoOrmData::createordertime() const
{
    return _ormRawPbData->createordertime();
}

void BorrowOrderInfoOrmData::set_createordertime(uint64_t value)
{
    _ormRawPbData->set_createordertime(value);
    _MaskDirty(true);
}

void BorrowOrderInfoOrmData::clear_orderstate()
{
    _ormRawPbData->clear_orderstate();
    _MaskDirty(true);
}

int32_t BorrowOrderInfoOrmData::orderstate() const
{
    return _ormRawPbData->orderstate();
}

void BorrowOrderInfoOrmData::set_orderstate(int32_t value)
{
    _ormRawPbData->set_orderstate(value);
    _MaskDirty(true);
}

KERNEL_NS::SmartPtr<CancelOrderReasonOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &BorrowOrderInfoOrmData::mutable_cancelreason()
{
    if(LIKELY(_cancelreason.AsSelf() != NULL))
        return _cancelreason;

        _cancelreason = SERVICE_COMMON_NS::CancelOrderReasonOrmData::NewThreadLocal_CancelOrderReasonOrmData(_ormRawPbData->mutable_cancelreason());

        _cancelreason.SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::CancelOrderReasonOrmData::DeleteThreadLocal_CancelOrderReasonOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::CancelOrderReasonOrmData>(ptr));
        }) ;

        _cancelreason->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

    return _cancelreason;
}

const ::CRYSTAL_NET::service::CancelOrderReason &BorrowOrderInfoOrmData::cancelreason() const
{
    return _ormRawPbData->cancelreason();
}

const KERNEL_NS::SmartPtr<CancelOrderReasonOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &BorrowOrderInfoOrmData::cancelreason_OrmData() const
{
    return _cancelreason;
}

bool BorrowOrderInfoOrmData::has_cancelreason() const
{
    return _ormRawPbData->has_cancelreason();
}

void BorrowOrderInfoOrmData::clear_cancelreason()
{
    if(_cancelreason)
        _cancelreason.Release();

    _ormRawPbData->clear_cancelreason();
    _MaskDirty(true);
}

void BorrowOrderInfoOrmData::clear_getovertime()
{
    _ormRawPbData->clear_getovertime();
    _MaskDirty(true);
}

int64_t BorrowOrderInfoOrmData::getovertime() const
{
    return _ormRawPbData->getovertime();
}

void BorrowOrderInfoOrmData::set_getovertime(int64_t value)
{
    _ormRawPbData->set_getovertime(value);
    _MaskDirty(true);
}

void BorrowOrderInfoOrmData::clear_remark()
{
    _ormRawPbData->clear_remark();
    _MaskDirty(true);
}

const std::string &BorrowOrderInfoOrmData::remark() const
{
    return _ormRawPbData->remark();
}

void BorrowOrderInfoOrmData::set_remark(const std::string &value)
{
    _ormRawPbData->set_remark(value);
    _MaskDirty(true);
}

std::string *BorrowOrderInfoOrmData::mutable_remark()
{
    _MaskDirty(true);
    return _ormRawPbData->mutable_remark();
}

void BorrowOrderInfoOrmData::clear_userid()
{
    _ormRawPbData->clear_userid();
    _MaskDirty(true);
}

uint64_t BorrowOrderInfoOrmData::userid() const
{
    return _ormRawPbData->userid();
}

void BorrowOrderInfoOrmData::set_userid(uint64_t value)
{
    _ormRawPbData->set_userid(value);
    _MaskDirty(true);
}

bool BorrowOrderInfoOrmData::_OnEncode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const
{
    return _ormRawPbData->Encode(stream);
}

bool BorrowOrderInfoOrmData::_OnEncode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const
{
    return _ormRawPbData->Encode(stream);
}

bool BorrowOrderInfoOrmData::_OnDecode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream)
{
    const auto ret = _ormRawPbData->Decode(stream);
    if(ret)
    {
        {
            const auto count = _ormRawPbData->borrowbooklist_size();
    
            _borrowbooklist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _borrowbooklist[idx] = SERVICE_COMMON_NS::BorrowBookInfoOrmData::NewThreadLocal_BorrowBookInfoOrmData(_ormRawPbData->mutable_borrowbooklist(idx));
    
            _borrowbooklist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::BorrowBookInfoOrmData::DeleteThreadLocal_BorrowBookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BorrowBookInfoOrmData>(ptr));
            }) ;
    
            _borrowbooklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
        if(_cancelreason)
            _cancelreason.Release();
    
        if(_ormRawPbData->has_cancelreason())
        {
            _cancelreason = SERVICE_COMMON_NS::CancelOrderReasonOrmData::NewThreadLocal_CancelOrderReasonOrmData(_ormRawPbData->mutable_cancelreason());
    
            _cancelreason.SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::CancelOrderReasonOrmData::DeleteThreadLocal_CancelOrderReasonOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::CancelOrderReasonOrmData>(ptr));
            }) ;
    
            _cancelreason->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
        }
    
    }

    return ret;
}

bool BorrowOrderInfoOrmData::_OnDecode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream)
{
    const auto ret = _ormRawPbData->Decode(stream);
    if(ret)
    {
        {
            const auto count = _ormRawPbData->borrowbooklist_size();
    
            _borrowbooklist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _borrowbooklist[idx] = SERVICE_COMMON_NS::BorrowBookInfoOrmData::NewThreadLocal_BorrowBookInfoOrmData(_ormRawPbData->mutable_borrowbooklist(idx));
    
            _borrowbooklist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::BorrowBookInfoOrmData::DeleteThreadLocal_BorrowBookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BorrowBookInfoOrmData>(ptr));
            }) ;
    
            _borrowbooklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
        if(_cancelreason)
            _cancelreason.Release();
    
        if(_ormRawPbData->has_cancelreason())
        {
            _cancelreason = SERVICE_COMMON_NS::CancelOrderReasonOrmData::NewThreadLocal_CancelOrderReasonOrmData(_ormRawPbData->mutable_cancelreason());
    
            _cancelreason.SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::CancelOrderReasonOrmData::DeleteThreadLocal_CancelOrderReasonOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::CancelOrderReasonOrmData>(ptr));
            }) ;
    
            _cancelreason->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
        }
    
    }

    return ret;
}

POOL_CREATE_OBJ_DEFAULT_IMPL(BorrowOrderInfoOrmDataFactory);

IOrmData *BorrowOrderInfoOrmDataFactory::Create() const
{
    return BorrowOrderInfoOrmData::NewThreadLocal_BorrowOrderInfoOrmData();
}


SERVICE_COMMON_END
