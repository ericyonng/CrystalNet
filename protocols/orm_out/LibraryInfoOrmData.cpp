/*!
*  MIT License
*  
*  Copyright (c) 2020 ericyonng<120453674@qq.com>
*  
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the "Software"), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*  
*  The above copyright notice and this permission notice shall be included in all
*  copies or substantial portions of the Software.
*  
*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*  SOFTWARE.
* 
* Author: Eric Yonng
* Description: Generated By protogentool, Dont Modify This File!!!
*/


#include "pch.h"
#include <protocols/cplusplus/library/com_library.pb.h>
#include <protocols/orm_out/LibraryInfoOrmData.h>
#include <protocols/orm_out/LibararyManagerInfoOrmData.h>
#include <protocols/cplusplus/library/com_library.pb.h>
#include <protocols/orm_out/MemberInfoOrmData.h>
#include <protocols/cplusplus/library/com_library.pb.h>
#include <protocols/orm_out/BookInfoOrmData.h>
#include <protocols/cplusplus/library/com_book.pb.h>

SERVICE_COMMON_BEGIN

POOL_CREATE_OBJ_DEFAULT_IMPL(LibraryInfoOrmData);

LibraryInfoOrmData::LibraryInfoOrmData()
:_ormRawPbData(new ::CRYSTAL_NET::service::LibraryInfo)
{
}

LibraryInfoOrmData::LibraryInfoOrmData(::CRYSTAL_NET::service::LibraryInfo *pb)
:_ormRawPbData(NULL)
{
    AttachPb(pb);
}

LibraryInfoOrmData::LibraryInfoOrmData(const LibraryInfoOrmData &other)
:IOrmData(reinterpret_cast<const IOrmData &>(other))
,_ormRawPbData(other._ormRawPbData ? new ::CRYSTAL_NET::service::LibraryInfo(*other._ormRawPbData) : NULL)
{
    SetAttachPbFlag(false);
    {
        const auto count = _ormRawPbData->managerinfolist_size();

        _managerinfolist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _managerinfolist[idx] = SERVICE_COMMON_NS::LibararyManagerInfoOrmData::NewThreadLocal_LibararyManagerInfoOrmData(_ormRawPbData->mutable_managerinfolist(idx));

        _managerinfolist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::LibararyManagerInfoOrmData::DeleteThreadLocal_LibararyManagerInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::LibararyManagerInfoOrmData>(ptr));
        }) ;

        _managerinfolist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    {
        const auto count = _ormRawPbData->memberlist_size();

        _memberlist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _memberlist[idx] = SERVICE_COMMON_NS::MemberInfoOrmData::NewThreadLocal_MemberInfoOrmData(_ormRawPbData->mutable_memberlist(idx));

        _memberlist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::MemberInfoOrmData::DeleteThreadLocal_MemberInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::MemberInfoOrmData>(ptr));
        }) ;

        _memberlist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    {
        const auto count = _ormRawPbData->booklist_size();

        _booklist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _booklist[idx] = SERVICE_COMMON_NS::BookInfoOrmData::NewThreadLocal_BookInfoOrmData(_ormRawPbData->mutable_booklist(idx));

        _booklist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::BookInfoOrmData::DeleteThreadLocal_BookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BookInfoOrmData>(ptr));
        }) ;

        _booklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


}

LibraryInfoOrmData::LibraryInfoOrmData(LibraryInfoOrmData &&other)
:IOrmData(std::forward<IOrmData>(other))
,_ormRawPbData(other._ormRawPbData)
{
    other._ormRawPbData = NULL;
    _managerinfolist = std::move(other._managerinfolist);

    _memberlist = std::move(other._memberlist);

    _booklist = std::move(other._booklist);

}

LibraryInfoOrmData::LibraryInfoOrmData(const ::CRYSTAL_NET::service::LibraryInfo &pb)
:_ormRawPbData(new ::CRYSTAL_NET::service::LibraryInfo(pb))
{
    {
        const auto count = _ormRawPbData->managerinfolist_size();

        _managerinfolist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _managerinfolist[idx] = SERVICE_COMMON_NS::LibararyManagerInfoOrmData::NewThreadLocal_LibararyManagerInfoOrmData(_ormRawPbData->mutable_managerinfolist(idx));

        _managerinfolist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::LibararyManagerInfoOrmData::DeleteThreadLocal_LibararyManagerInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::LibararyManagerInfoOrmData>(ptr));
        }) ;

        _managerinfolist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    {
        const auto count = _ormRawPbData->memberlist_size();

        _memberlist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _memberlist[idx] = SERVICE_COMMON_NS::MemberInfoOrmData::NewThreadLocal_MemberInfoOrmData(_ormRawPbData->mutable_memberlist(idx));

        _memberlist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::MemberInfoOrmData::DeleteThreadLocal_MemberInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::MemberInfoOrmData>(ptr));
        }) ;

        _memberlist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    {
        const auto count = _ormRawPbData->booklist_size();

        _booklist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _booklist[idx] = SERVICE_COMMON_NS::BookInfoOrmData::NewThreadLocal_BookInfoOrmData(_ormRawPbData->mutable_booklist(idx));

        _booklist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::BookInfoOrmData::DeleteThreadLocal_BookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BookInfoOrmData>(ptr));
        }) ;

        _booklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }



}

LibraryInfoOrmData::~LibraryInfoOrmData()
{
    if(LIKELY(!IsAttachPb()))
        CRYSTAL_RELEASE_SAFE(_ormRawPbData);
}

void LibraryInfoOrmData::Release()
{
    LibraryInfoOrmData::DeleteThreadLocal_LibraryInfoOrmData(this);
}

LibraryInfoOrmData &LibraryInfoOrmData::operator =(const ::CRYSTAL_NET::service::LibraryInfo &pb)
{
    if(LIKELY(!IsAttachPb()))
        CRYSTAL_RELEASE_SAFE(_ormRawPbData);

    SetAttachPbFlag(false);
    _ormRawPbData = new ::CRYSTAL_NET::service::LibraryInfo(pb);
    {
        const auto count = _ormRawPbData->managerinfolist_size();

        _managerinfolist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _managerinfolist[idx] = SERVICE_COMMON_NS::LibararyManagerInfoOrmData::NewThreadLocal_LibararyManagerInfoOrmData(_ormRawPbData->mutable_managerinfolist(idx));

        _managerinfolist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::LibararyManagerInfoOrmData::DeleteThreadLocal_LibararyManagerInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::LibararyManagerInfoOrmData>(ptr));
        }) ;

        _managerinfolist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    {
        const auto count = _ormRawPbData->memberlist_size();

        _memberlist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _memberlist[idx] = SERVICE_COMMON_NS::MemberInfoOrmData::NewThreadLocal_MemberInfoOrmData(_ormRawPbData->mutable_memberlist(idx));

        _memberlist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::MemberInfoOrmData::DeleteThreadLocal_MemberInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::MemberInfoOrmData>(ptr));
        }) ;

        _memberlist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    {
        const auto count = _ormRawPbData->booklist_size();

        _booklist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _booklist[idx] = SERVICE_COMMON_NS::BookInfoOrmData::NewThreadLocal_BookInfoOrmData(_ormRawPbData->mutable_booklist(idx));

        _booklist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::BookInfoOrmData::DeleteThreadLocal_BookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BookInfoOrmData>(ptr));
        }) ;

        _booklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    _MaskDirty(true);
    return *this;
}

LibraryInfoOrmData &LibraryInfoOrmData::operator =(const LibraryInfoOrmData &other)
{
    if(this == &other)
        return *this;

    IOrmData::operator =(reinterpret_cast<const IOrmData &>(other));
    if(LIKELY(!IsAttachPb()))
        CRYSTAL_RELEASE_SAFE(_ormRawPbData);

    _ormRawPbData = NULL;
    SetAttachPbFlag(false);
    if(other._ormRawPbData)
        _ormRawPbData = new ::CRYSTAL_NET::service::LibraryInfo(*other._ormRawPbData);
    if(_ormRawPbData)
    {
            {
                const auto count = _ormRawPbData->managerinfolist_size();
        
                _managerinfolist.resize(count);
        
                for(Int32 idx = 0; idx < count; ++idx)
                {
                _managerinfolist[idx] = SERVICE_COMMON_NS::LibararyManagerInfoOrmData::NewThreadLocal_LibararyManagerInfoOrmData(_ormRawPbData->mutable_managerinfolist(idx));
        
                _managerinfolist[idx].SetClosureDelegate([](void *ptr){
                    SERVICE_COMMON_NS::LibararyManagerInfoOrmData::DeleteThreadLocal_LibararyManagerInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::LibararyManagerInfoOrmData>(ptr));
                }) ;
        
                _managerinfolist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                    _MaskDirty(true);
                }) ;
        
                }
            }
        
        
            {
                const auto count = _ormRawPbData->memberlist_size();
        
                _memberlist.resize(count);
        
                for(Int32 idx = 0; idx < count; ++idx)
                {
                _memberlist[idx] = SERVICE_COMMON_NS::MemberInfoOrmData::NewThreadLocal_MemberInfoOrmData(_ormRawPbData->mutable_memberlist(idx));
        
                _memberlist[idx].SetClosureDelegate([](void *ptr){
                    SERVICE_COMMON_NS::MemberInfoOrmData::DeleteThreadLocal_MemberInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::MemberInfoOrmData>(ptr));
                }) ;
        
                _memberlist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                    _MaskDirty(true);
                }) ;
        
                }
            }
        
        
            {
                const auto count = _ormRawPbData->booklist_size();
        
                _booklist.resize(count);
        
                for(Int32 idx = 0; idx < count; ++idx)
                {
                _booklist[idx] = SERVICE_COMMON_NS::BookInfoOrmData::NewThreadLocal_BookInfoOrmData(_ormRawPbData->mutable_booklist(idx));
        
                _booklist[idx].SetClosureDelegate([](void *ptr){
                    SERVICE_COMMON_NS::BookInfoOrmData::DeleteThreadLocal_BookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BookInfoOrmData>(ptr));
                }) ;
        
                _booklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                    _MaskDirty(true);
                }) ;
        
                }
            }
        
        
    }
    _MaskDirty(true);

    return *this;
}

LibraryInfoOrmData &LibraryInfoOrmData::operator =(LibraryInfoOrmData &&other)
{
    if(this == &other)
        return *this;

    IOrmData::operator =(std::forward<IOrmData>(other));
    _ormRawPbData = other._ormRawPbData;
    other._ormRawPbData = NULL;

    _managerinfolist = std::move(other._managerinfolist);

    _memberlist = std::move(other._memberlist);

    _booklist = std::move(other._booklist);


    return *this;
}

void LibraryInfoOrmData::Clear()
{
    _managerinfolist.clear();

    _memberlist.clear();

    _booklist.clear();


    if(_ormRawPbData)
        _ormRawPbData->Clear();

    _MaskDirty(true);
}

void LibraryInfoOrmData::_AttachPb(void *pb)
{
    if(LIKELY(!IsAttachPb()))
        CRYSTAL_RELEASE_SAFE(_ormRawPbData);

    _ormRawPbData = reinterpret_cast<::CRYSTAL_NET::service::LibraryInfo *>(pb);

    {
        const auto count = _ormRawPbData->managerinfolist_size();

        _managerinfolist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _managerinfolist[idx] = SERVICE_COMMON_NS::LibararyManagerInfoOrmData::NewThreadLocal_LibararyManagerInfoOrmData(_ormRawPbData->mutable_managerinfolist(idx));

        _managerinfolist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::LibararyManagerInfoOrmData::DeleteThreadLocal_LibararyManagerInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::LibararyManagerInfoOrmData>(ptr));
        }) ;

        _managerinfolist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    {
        const auto count = _ormRawPbData->memberlist_size();

        _memberlist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _memberlist[idx] = SERVICE_COMMON_NS::MemberInfoOrmData::NewThreadLocal_MemberInfoOrmData(_ormRawPbData->mutable_memberlist(idx));

        _memberlist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::MemberInfoOrmData::DeleteThreadLocal_MemberInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::MemberInfoOrmData>(ptr));
        }) ;

        _memberlist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }


    {
        const auto count = _ormRawPbData->booklist_size();

        _booklist.resize(count);

        for(Int32 idx = 0; idx < count; ++idx)
        {
        _booklist[idx] = SERVICE_COMMON_NS::BookInfoOrmData::NewThreadLocal_BookInfoOrmData(_ormRawPbData->mutable_booklist(idx));

        _booklist[idx].SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::BookInfoOrmData::DeleteThreadLocal_BookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BookInfoOrmData>(ptr));
        }) ;

        _booklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

        }
    }



}

KERNEL_NS::LibString LibraryInfoOrmData::ToJsonString() const
{
    return _ormRawPbData->ToJsonString();
}

bool LibraryInfoOrmData::ToJsonString(std::string *data) const
{
    return _ormRawPbData->ToJsonString(data);
}

bool LibraryInfoOrmData::FromJsonString(const Byte8 *data, size_t len)
{
    const auto ret = _ormRawPbData->FromJsonString(data, len);
    if(ret)
    {
        {
            const auto count = _ormRawPbData->managerinfolist_size();
    
            _managerinfolist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _managerinfolist[idx] = SERVICE_COMMON_NS::LibararyManagerInfoOrmData::NewThreadLocal_LibararyManagerInfoOrmData(_ormRawPbData->mutable_managerinfolist(idx));
    
            _managerinfolist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::LibararyManagerInfoOrmData::DeleteThreadLocal_LibararyManagerInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::LibararyManagerInfoOrmData>(ptr));
            }) ;
    
            _managerinfolist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
        {
            const auto count = _ormRawPbData->memberlist_size();
    
            _memberlist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _memberlist[idx] = SERVICE_COMMON_NS::MemberInfoOrmData::NewThreadLocal_MemberInfoOrmData(_ormRawPbData->mutable_memberlist(idx));
    
            _memberlist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::MemberInfoOrmData::DeleteThreadLocal_MemberInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::MemberInfoOrmData>(ptr));
            }) ;
    
            _memberlist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
        {
            const auto count = _ormRawPbData->booklist_size();
    
            _booklist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _booklist[idx] = SERVICE_COMMON_NS::BookInfoOrmData::NewThreadLocal_BookInfoOrmData(_ormRawPbData->mutable_booklist(idx));
    
            _booklist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::BookInfoOrmData::DeleteThreadLocal_BookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BookInfoOrmData>(ptr));
            }) ;
    
            _booklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
    }

    return ret;
}

const ::CRYSTAL_NET::service::LibraryInfo *LibraryInfoOrmData::GetPbRawData() const
{
    return _ormRawPbData;
}

void LibraryInfoOrmData::clear_id()
{
    _ormRawPbData->clear_id();
    _MaskDirty(true);
}

uint64_t LibraryInfoOrmData::id() const
{
    return _ormRawPbData->id();
}

void LibraryInfoOrmData::set_id(uint64_t value)
{
    _ormRawPbData->set_id(value);
    _MaskDirty(true);
}

void LibraryInfoOrmData::clear_name()
{
    _ormRawPbData->clear_name();
    _MaskDirty(true);
}

const std::string &LibraryInfoOrmData::name() const
{
    return _ormRawPbData->name();
}

void LibraryInfoOrmData::set_name(const std::string &value)
{
    _ormRawPbData->set_name(value);
    _MaskDirty(true);
}

std::string *LibraryInfoOrmData::mutable_name()
{
    _MaskDirty(true);
    return _ormRawPbData->mutable_name();
}

void LibraryInfoOrmData::clear_address()
{
    _ormRawPbData->clear_address();
    _MaskDirty(true);
}

const std::string &LibraryInfoOrmData::address() const
{
    return _ormRawPbData->address();
}

void LibraryInfoOrmData::set_address(const std::string &value)
{
    _ormRawPbData->set_address(value);
    _MaskDirty(true);
}

std::string *LibraryInfoOrmData::mutable_address()
{
    _MaskDirty(true);
    return _ormRawPbData->mutable_address();
}

void LibraryInfoOrmData::clear_opentime()
{
    _ormRawPbData->clear_opentime();
    _MaskDirty(true);
}

const std::string &LibraryInfoOrmData::opentime() const
{
    return _ormRawPbData->opentime();
}

void LibraryInfoOrmData::set_opentime(const std::string &value)
{
    _ormRawPbData->set_opentime(value);
    _MaskDirty(true);
}

std::string *LibraryInfoOrmData::mutable_opentime()
{
    _MaskDirty(true);
    return _ormRawPbData->mutable_opentime();
}

void LibraryInfoOrmData::clear_telphonenumber()
{
    _ormRawPbData->clear_telphonenumber();
    _MaskDirty(true);
}

const std::string &LibraryInfoOrmData::telphonenumber() const
{
    return _ormRawPbData->telphonenumber();
}

void LibraryInfoOrmData::set_telphonenumber(const std::string &value)
{
    _ormRawPbData->set_telphonenumber(value);
    _MaskDirty(true);
}

std::string *LibraryInfoOrmData::mutable_telphonenumber()
{
    _MaskDirty(true);
    return _ormRawPbData->mutable_telphonenumber();
}

void LibraryInfoOrmData::clear_librarianuserid()
{
    _ormRawPbData->clear_librarianuserid();
    _MaskDirty(true);
}

uint64_t LibraryInfoOrmData::librarianuserid() const
{
    return _ormRawPbData->librarianuserid();
}

void LibraryInfoOrmData::set_librarianuserid(uint64_t value)
{
    _ormRawPbData->set_librarianuserid(value);
    _MaskDirty(true);
}

void LibraryInfoOrmData::clear_librarianusernickname()
{
    _ormRawPbData->clear_librarianusernickname();
    _MaskDirty(true);
}

const std::string &LibraryInfoOrmData::librarianusernickname() const
{
    return _ormRawPbData->librarianusernickname();
}

void LibraryInfoOrmData::set_librarianusernickname(const std::string &value)
{
    _ormRawPbData->set_librarianusernickname(value);
    _MaskDirty(true);
}

std::string *LibraryInfoOrmData::mutable_librarianusernickname()
{
    _MaskDirty(true);
    return _ormRawPbData->mutable_librarianusernickname();
}

Int32 LibraryInfoOrmData::managerinfolist_size() const
{
    return _ormRawPbData->managerinfolist_size();
}

KERNEL_NS::SmartPtr<LibararyManagerInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &LibraryInfoOrmData::mutable_managerinfolist(Int32 idx)
{
    return _managerinfolist[idx];
}

void LibraryInfoOrmData::DeleteArray_managerinfolist(Int32 idx, Int32 count)
{
    for(Int32 pos = idx + count - 1; pos >= idx; --pos)
    {
        _managerinfolist.erase(_managerinfolist.begin() + pos);
    }

    _ormRawPbData->mutable_managerinfolist()->DeleteSubrange(idx, count);
    _MaskDirty(true);
}

const std::vector<KERNEL_NS::SmartPtr<LibararyManagerInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete>> &LibraryInfoOrmData::managerinfolist_OrmDataArray() const
{
    return _managerinfolist;
}

const ::google::protobuf::RepeatedPtrField<::CRYSTAL_NET::service::LibararyManagerInfo> &LibraryInfoOrmData::managerinfolist() const
{
    return _ormRawPbData->managerinfolist();
}

const KERNEL_NS::SmartPtr<LibararyManagerInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &LibraryInfoOrmData::managerinfolist_OrmDataArray(Int32 idx) const
{
    return _managerinfolist[idx];
}

const ::CRYSTAL_NET::service::LibararyManagerInfo &LibraryInfoOrmData::managerinfolist(Int32 idx) const
{
    return _ormRawPbData->managerinfolist(idx);
}

KERNEL_NS::SmartPtr<LibararyManagerInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &LibraryInfoOrmData::add_managerinfolist()
{
    auto newPb = _ormRawPbData->add_managerinfolist();
    _managerinfolist.push_back(KERNEL_NS::SmartPtr<LibararyManagerInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete>());
    auto &elem = _managerinfolist.back();
        elem = SERVICE_COMMON_NS::LibararyManagerInfoOrmData::NewThreadLocal_LibararyManagerInfoOrmData(newPb);

        elem.SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::LibararyManagerInfoOrmData::DeleteThreadLocal_LibararyManagerInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::LibararyManagerInfoOrmData>(ptr));
        }) ;

        elem->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

    _MaskDirty(true);
    return elem;
}

void LibraryInfoOrmData::clear_managerinfolist()
{
    _ormRawPbData->clear_managerinfolist();
    _managerinfolist.clear();
    _MaskDirty(true);
}

Int32 LibraryInfoOrmData::memberlist_size() const
{
    return _ormRawPbData->memberlist_size();
}

KERNEL_NS::SmartPtr<MemberInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &LibraryInfoOrmData::mutable_memberlist(Int32 idx)
{
    return _memberlist[idx];
}

void LibraryInfoOrmData::DeleteArray_memberlist(Int32 idx, Int32 count)
{
    for(Int32 pos = idx + count - 1; pos >= idx; --pos)
    {
        _memberlist.erase(_memberlist.begin() + pos);
    }

    _ormRawPbData->mutable_memberlist()->DeleteSubrange(idx, count);
    _MaskDirty(true);
}

const std::vector<KERNEL_NS::SmartPtr<MemberInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete>> &LibraryInfoOrmData::memberlist_OrmDataArray() const
{
    return _memberlist;
}

const ::google::protobuf::RepeatedPtrField<::CRYSTAL_NET::service::MemberInfo> &LibraryInfoOrmData::memberlist() const
{
    return _ormRawPbData->memberlist();
}

const KERNEL_NS::SmartPtr<MemberInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &LibraryInfoOrmData::memberlist_OrmDataArray(Int32 idx) const
{
    return _memberlist[idx];
}

const ::CRYSTAL_NET::service::MemberInfo &LibraryInfoOrmData::memberlist(Int32 idx) const
{
    return _ormRawPbData->memberlist(idx);
}

KERNEL_NS::SmartPtr<MemberInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &LibraryInfoOrmData::add_memberlist()
{
    auto newPb = _ormRawPbData->add_memberlist();
    _memberlist.push_back(KERNEL_NS::SmartPtr<MemberInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete>());
    auto &elem = _memberlist.back();
        elem = SERVICE_COMMON_NS::MemberInfoOrmData::NewThreadLocal_MemberInfoOrmData(newPb);

        elem.SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::MemberInfoOrmData::DeleteThreadLocal_MemberInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::MemberInfoOrmData>(ptr));
        }) ;

        elem->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

    _MaskDirty(true);
    return elem;
}

void LibraryInfoOrmData::clear_memberlist()
{
    _ormRawPbData->clear_memberlist();
    _memberlist.clear();
    _MaskDirty(true);
}

Int32 LibraryInfoOrmData::booklist_size() const
{
    return _ormRawPbData->booklist_size();
}

KERNEL_NS::SmartPtr<BookInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &LibraryInfoOrmData::mutable_booklist(Int32 idx)
{
    return _booklist[idx];
}

void LibraryInfoOrmData::DeleteArray_booklist(Int32 idx, Int32 count)
{
    for(Int32 pos = idx + count - 1; pos >= idx; --pos)
    {
        _booklist.erase(_booklist.begin() + pos);
    }

    _ormRawPbData->mutable_booklist()->DeleteSubrange(idx, count);
    _MaskDirty(true);
}

const std::vector<KERNEL_NS::SmartPtr<BookInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete>> &LibraryInfoOrmData::booklist_OrmDataArray() const
{
    return _booklist;
}

const ::google::protobuf::RepeatedPtrField<::CRYSTAL_NET::service::BookInfo> &LibraryInfoOrmData::booklist() const
{
    return _ormRawPbData->booklist();
}

const KERNEL_NS::SmartPtr<BookInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &LibraryInfoOrmData::booklist_OrmDataArray(Int32 idx) const
{
    return _booklist[idx];
}

const ::CRYSTAL_NET::service::BookInfo &LibraryInfoOrmData::booklist(Int32 idx) const
{
    return _ormRawPbData->booklist(idx);
}

KERNEL_NS::SmartPtr<BookInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete> &LibraryInfoOrmData::add_booklist()
{
    auto newPb = _ormRawPbData->add_booklist();
    _booklist.push_back(KERNEL_NS::SmartPtr<BookInfoOrmData, KERNEL_NS::AutoDelMethods::CustomDelete>());
    auto &elem = _booklist.back();
        elem = SERVICE_COMMON_NS::BookInfoOrmData::NewThreadLocal_BookInfoOrmData(newPb);

        elem.SetClosureDelegate([](void *ptr){
            SERVICE_COMMON_NS::BookInfoOrmData::DeleteThreadLocal_BookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BookInfoOrmData>(ptr));
        }) ;

        elem->SetMaskDirtyCallback([this](IOrmData *ptr){
            _MaskDirty(true);
        }) ;

    _MaskDirty(true);
    return elem;
}

void LibraryInfoOrmData::clear_booklist()
{
    _ormRawPbData->clear_booklist();
    _booklist.clear();
    _MaskDirty(true);
}

bool LibraryInfoOrmData::_OnEncode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const
{
    return _ormRawPbData->Encode(stream);
}

bool LibraryInfoOrmData::_OnEncode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const
{
    return _ormRawPbData->Encode(stream);
}

bool LibraryInfoOrmData::_OnDecode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream)
{
    const auto ret = _ormRawPbData->Decode(stream);
    if(ret)
    {
        {
            const auto count = _ormRawPbData->managerinfolist_size();
    
            _managerinfolist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _managerinfolist[idx] = SERVICE_COMMON_NS::LibararyManagerInfoOrmData::NewThreadLocal_LibararyManagerInfoOrmData(_ormRawPbData->mutable_managerinfolist(idx));
    
            _managerinfolist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::LibararyManagerInfoOrmData::DeleteThreadLocal_LibararyManagerInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::LibararyManagerInfoOrmData>(ptr));
            }) ;
    
            _managerinfolist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
        {
            const auto count = _ormRawPbData->memberlist_size();
    
            _memberlist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _memberlist[idx] = SERVICE_COMMON_NS::MemberInfoOrmData::NewThreadLocal_MemberInfoOrmData(_ormRawPbData->mutable_memberlist(idx));
    
            _memberlist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::MemberInfoOrmData::DeleteThreadLocal_MemberInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::MemberInfoOrmData>(ptr));
            }) ;
    
            _memberlist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
        {
            const auto count = _ormRawPbData->booklist_size();
    
            _booklist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _booklist[idx] = SERVICE_COMMON_NS::BookInfoOrmData::NewThreadLocal_BookInfoOrmData(_ormRawPbData->mutable_booklist(idx));
    
            _booklist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::BookInfoOrmData::DeleteThreadLocal_BookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BookInfoOrmData>(ptr));
            }) ;
    
            _booklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
    }

    return ret;
}

bool LibraryInfoOrmData::_OnDecode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream)
{
    const auto ret = _ormRawPbData->Decode(stream);
    if(ret)
    {
        {
            const auto count = _ormRawPbData->managerinfolist_size();
    
            _managerinfolist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _managerinfolist[idx] = SERVICE_COMMON_NS::LibararyManagerInfoOrmData::NewThreadLocal_LibararyManagerInfoOrmData(_ormRawPbData->mutable_managerinfolist(idx));
    
            _managerinfolist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::LibararyManagerInfoOrmData::DeleteThreadLocal_LibararyManagerInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::LibararyManagerInfoOrmData>(ptr));
            }) ;
    
            _managerinfolist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
        {
            const auto count = _ormRawPbData->memberlist_size();
    
            _memberlist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _memberlist[idx] = SERVICE_COMMON_NS::MemberInfoOrmData::NewThreadLocal_MemberInfoOrmData(_ormRawPbData->mutable_memberlist(idx));
    
            _memberlist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::MemberInfoOrmData::DeleteThreadLocal_MemberInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::MemberInfoOrmData>(ptr));
            }) ;
    
            _memberlist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
        {
            const auto count = _ormRawPbData->booklist_size();
    
            _booklist.resize(count);
    
            for(Int32 idx = 0; idx < count; ++idx)
            {
            _booklist[idx] = SERVICE_COMMON_NS::BookInfoOrmData::NewThreadLocal_BookInfoOrmData(_ormRawPbData->mutable_booklist(idx));
    
            _booklist[idx].SetClosureDelegate([](void *ptr){
                SERVICE_COMMON_NS::BookInfoOrmData::DeleteThreadLocal_BookInfoOrmData(KERNEL_NS::KernelCastTo<SERVICE_COMMON_NS::BookInfoOrmData>(ptr));
            }) ;
    
            _booklist[idx]->SetMaskDirtyCallback([this](IOrmData *ptr){
                _MaskDirty(true);
            }) ;
    
            }
        }
    
    
    }

    return ret;
}

POOL_CREATE_OBJ_DEFAULT_IMPL(LibraryInfoOrmDataFactory);

IOrmData *LibraryInfoOrmDataFactory::Create() const
{
    return LibraryInfoOrmData::NewThreadLocal_LibraryInfoOrmData();
}


SERVICE_COMMON_END
