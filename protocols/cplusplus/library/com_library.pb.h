// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: com_library.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_com_5flibrary_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_com_5flibrary_2eproto

// KERNEL_INCLUDED
#include <kernel/kernel.h>
#include <service_common/ServiceCommon.h>
#include <google/protobuf/util/json_util.h>
#include <google/protobuf/text_format.h>

#ifdef GetMessage
 #undef GetMessage
#endif


#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "com_book.pb.h"
#include "com_variant.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_com_5flibrary_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_com_5flibrary_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_com_5flibrary_2eproto;
namespace CRYSTAL_NET {
namespace service {
class BorrowBookInfo;
struct BorrowBookInfoDefaultTypeInternal;
extern BorrowBookInfoDefaultTypeInternal _BorrowBookInfo_default_instance_;
class BorrowOrderInfo;
struct BorrowOrderInfoDefaultTypeInternal;
extern BorrowOrderInfoDefaultTypeInternal _BorrowOrderInfo_default_instance_;
class BorrowOrderState;
struct BorrowOrderStateDefaultTypeInternal;
extern BorrowOrderStateDefaultTypeInternal _BorrowOrderState_default_instance_;
class KeyWordsField;
struct KeyWordsFieldDefaultTypeInternal;
extern KeyWordsFieldDefaultTypeInternal _KeyWordsField_default_instance_;
class LibararyManagerInfo;
struct LibararyManagerInfoDefaultTypeInternal;
extern LibararyManagerInfoDefaultTypeInternal _LibararyManagerInfo_default_instance_;
class LibraryInfo;
struct LibraryInfoDefaultTypeInternal;
extern LibraryInfoDefaultTypeInternal _LibraryInfo_default_instance_;
class LibraryPreviewInfo;
struct LibraryPreviewInfoDefaultTypeInternal;
extern LibraryPreviewInfoDefaultTypeInternal _LibraryPreviewInfo_default_instance_;
class MemberInfo;
struct MemberInfoDefaultTypeInternal;
extern MemberInfoDefaultTypeInternal _MemberInfo_default_instance_;
class OperationLogInfo;
struct OperationLogInfoDefaultTypeInternal;
extern OperationLogInfoDefaultTypeInternal _OperationLogInfo_default_instance_;
class OperationType;
struct OperationTypeDefaultTypeInternal;
extern OperationTypeDefaultTypeInternal _OperationType_default_instance_;
class RoleType;
struct RoleTypeDefaultTypeInternal;
extern RoleTypeDefaultTypeInternal _RoleType_default_instance_;
class SnapshotField;
struct SnapshotFieldDefaultTypeInternal;
extern SnapshotFieldDefaultTypeInternal _SnapshotField_default_instance_;
class UserLibraryInfo;
struct UserLibraryInfoDefaultTypeInternal;
extern UserLibraryInfoDefaultTypeInternal _UserLibraryInfo_default_instance_;
}  // namespace service
}  // namespace CRYSTAL_NET
PROTOBUF_NAMESPACE_OPEN
template<> ::CRYSTAL_NET::service::BorrowBookInfo* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::BorrowBookInfo>(Arena*);
template<> ::CRYSTAL_NET::service::BorrowOrderInfo* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::BorrowOrderInfo>(Arena*);
template<> ::CRYSTAL_NET::service::BorrowOrderState* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::BorrowOrderState>(Arena*);
template<> ::CRYSTAL_NET::service::KeyWordsField* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::KeyWordsField>(Arena*);
template<> ::CRYSTAL_NET::service::LibararyManagerInfo* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::LibararyManagerInfo>(Arena*);
template<> ::CRYSTAL_NET::service::LibraryInfo* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::LibraryInfo>(Arena*);
template<> ::CRYSTAL_NET::service::LibraryPreviewInfo* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::LibraryPreviewInfo>(Arena*);
template<> ::CRYSTAL_NET::service::MemberInfo* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::MemberInfo>(Arena*);
template<> ::CRYSTAL_NET::service::OperationLogInfo* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::OperationLogInfo>(Arena*);
template<> ::CRYSTAL_NET::service::OperationType* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::OperationType>(Arena*);
template<> ::CRYSTAL_NET::service::RoleType* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::RoleType>(Arena*);
template<> ::CRYSTAL_NET::service::SnapshotField* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::SnapshotField>(Arena*);
template<> ::CRYSTAL_NET::service::UserLibraryInfo* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::UserLibraryInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CRYSTAL_NET {
namespace service {

enum RoleType_ENUMS : int {
  RoleType_ENUMS_NoAuth = 0,
  RoleType_ENUMS_NormalMember = 1,
  RoleType_ENUMS_Manager = 2,
  RoleType_ENUMS_Librarian = 3,
  RoleType_ENUMS_RoleType_ENUMS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RoleType_ENUMS_RoleType_ENUMS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RoleType_ENUMS_IsValid(int value);
constexpr RoleType_ENUMS RoleType_ENUMS_ENUMS_MIN = RoleType_ENUMS_NoAuth;
constexpr RoleType_ENUMS RoleType_ENUMS_ENUMS_MAX = RoleType_ENUMS_Librarian;
constexpr int RoleType_ENUMS_ENUMS_ARRAYSIZE = RoleType_ENUMS_ENUMS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoleType_ENUMS_descriptor();
template<typename T>
inline const std::string& RoleType_ENUMS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoleType_ENUMS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoleType_ENUMS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoleType_ENUMS_descriptor(), enum_t_value);
}
inline bool RoleType_ENUMS_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoleType_ENUMS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoleType_ENUMS>(
    RoleType_ENUMS_descriptor(), name, value);
}
enum BorrowOrderState_ENUMS : int {
  BorrowOrderState_ENUMS_WAITING_MANAGER_CONFIRM = 0,
  BorrowOrderState_ENUMS_ORDER_CONFIRM = 1,
  BorrowOrderState_ENUMS_WAIT_USER_RECEIVE = 2,
  BorrowOrderState_ENUMS_WAIT_USER_RETURN_BACK = 3,
  BorrowOrderState_ENUMS_USER_RETURN_BACK_ALL_BOOKS = 4,
  BorrowOrderState_ENUMS_CANCEL_ORDER = 5,
  BorrowOrderState_ENUMS_RETURN_BAKCK = 6,
  BorrowOrderState_ENUMS_BorrowOrderState_ENUMS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BorrowOrderState_ENUMS_BorrowOrderState_ENUMS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BorrowOrderState_ENUMS_IsValid(int value);
constexpr BorrowOrderState_ENUMS BorrowOrderState_ENUMS_ENUMS_MIN = BorrowOrderState_ENUMS_WAITING_MANAGER_CONFIRM;
constexpr BorrowOrderState_ENUMS BorrowOrderState_ENUMS_ENUMS_MAX = BorrowOrderState_ENUMS_RETURN_BAKCK;
constexpr int BorrowOrderState_ENUMS_ENUMS_ARRAYSIZE = BorrowOrderState_ENUMS_ENUMS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BorrowOrderState_ENUMS_descriptor();
template<typename T>
inline const std::string& BorrowOrderState_ENUMS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BorrowOrderState_ENUMS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BorrowOrderState_ENUMS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BorrowOrderState_ENUMS_descriptor(), enum_t_value);
}
inline bool BorrowOrderState_ENUMS_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BorrowOrderState_ENUMS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BorrowOrderState_ENUMS>(
    BorrowOrderState_ENUMS_descriptor(), name, value);
}
enum OperationType_ENUMS : int {
  OperationType_ENUMS_UNKNOWN = 0,
  OperationType_ENUMS_OperationType_ENUMS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OperationType_ENUMS_OperationType_ENUMS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OperationType_ENUMS_IsValid(int value);
constexpr OperationType_ENUMS OperationType_ENUMS_ENUMS_MIN = OperationType_ENUMS_UNKNOWN;
constexpr OperationType_ENUMS OperationType_ENUMS_ENUMS_MAX = OperationType_ENUMS_UNKNOWN;
constexpr int OperationType_ENUMS_ENUMS_ARRAYSIZE = OperationType_ENUMS_ENUMS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperationType_ENUMS_descriptor();
template<typename T>
inline const std::string& OperationType_ENUMS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperationType_ENUMS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperationType_ENUMS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OperationType_ENUMS_descriptor(), enum_t_value);
}
inline bool OperationType_ENUMS_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OperationType_ENUMS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperationType_ENUMS>(
    OperationType_ENUMS_descriptor(), name, value);
}
// ===================================================================

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class RoleType final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.RoleType) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message RoleType failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message RoleType failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message RoleType failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message RoleType failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message RoleType failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message RoleType failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline RoleType() : RoleType(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RoleType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleType(const RoleType& from);
  RoleType(RoleType&& from) noexcept
    : RoleType() {
    *this = ::std::move(from);
  }

  inline RoleType& operator=(const RoleType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleType& operator=(RoleType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleType& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleType* internal_default_instance() {
    return reinterpret_cast<const RoleType*>(
               &_RoleType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RoleType& a, RoleType& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RoleType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RoleType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.RoleType";
  }
  protected:
  explicit RoleType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoleType_ENUMS ENUMS;
  static constexpr ENUMS NoAuth =
    RoleType_ENUMS_NoAuth;
  static constexpr ENUMS NormalMember =
    RoleType_ENUMS_NormalMember;
  static constexpr ENUMS Manager =
    RoleType_ENUMS_Manager;
  static constexpr ENUMS Librarian =
    RoleType_ENUMS_Librarian;
  static inline bool ENUMS_IsValid(int value) {
    return RoleType_ENUMS_IsValid(value);
  }
  static constexpr ENUMS ENUMS_MIN =
    RoleType_ENUMS_ENUMS_MIN;
  static constexpr ENUMS ENUMS_MAX =
    RoleType_ENUMS_ENUMS_MAX;
  static constexpr int ENUMS_ARRAYSIZE =
    RoleType_ENUMS_ENUMS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ENUMS_descriptor() {
    return RoleType_ENUMS_descriptor();
  }
  template<typename T>
  static inline const std::string& ENUMS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ENUMS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ENUMS_Name.");
    return RoleType_ENUMS_Name(enum_t_value);
  }
  static inline bool ENUMS_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ENUMS* value) {
    return RoleType_ENUMS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.RoleType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class LibararyManagerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.LibararyManagerInfo) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibararyManagerInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibararyManagerInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibararyManagerInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibararyManagerInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message LibararyManagerInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message LibararyManagerInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline LibararyManagerInfo() : LibararyManagerInfo(nullptr) {}
  ~LibararyManagerInfo() override;
  explicit PROTOBUF_CONSTEXPR LibararyManagerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibararyManagerInfo(const LibararyManagerInfo& from);
  LibararyManagerInfo(LibararyManagerInfo&& from) noexcept
    : LibararyManagerInfo() {
    *this = ::std::move(from);
  }

  inline LibararyManagerInfo& operator=(const LibararyManagerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibararyManagerInfo& operator=(LibararyManagerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibararyManagerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibararyManagerInfo* internal_default_instance() {
    return reinterpret_cast<const LibararyManagerInfo*>(
               &_LibararyManagerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LibararyManagerInfo& a, LibararyManagerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LibararyManagerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibararyManagerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibararyManagerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibararyManagerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibararyManagerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibararyManagerInfo& from) {
    LibararyManagerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibararyManagerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.LibararyManagerInfo";
  }
  protected:
  explicit LibararyManagerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // uint64 UserId = 1;
  void clear_userid();
  uint64_t userid() const;
  void set_userid(uint64_t value);
  private:
  uint64_t _internal_userid() const;
  void _internal_set_userid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.LibararyManagerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class BorrowBookInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.BorrowBookInfo) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowBookInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowBookInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowBookInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowBookInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message BorrowBookInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message BorrowBookInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline BorrowBookInfo() : BorrowBookInfo(nullptr) {}
  ~BorrowBookInfo() override;
  explicit PROTOBUF_CONSTEXPR BorrowBookInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BorrowBookInfo(const BorrowBookInfo& from);
  BorrowBookInfo(BorrowBookInfo&& from) noexcept
    : BorrowBookInfo() {
    *this = ::std::move(from);
  }

  inline BorrowBookInfo& operator=(const BorrowBookInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BorrowBookInfo& operator=(BorrowBookInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BorrowBookInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BorrowBookInfo* internal_default_instance() {
    return reinterpret_cast<const BorrowBookInfo*>(
               &_BorrowBookInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BorrowBookInfo& a, BorrowBookInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BorrowBookInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BorrowBookInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BorrowBookInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BorrowBookInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BorrowBookInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BorrowBookInfo& from) {
    BorrowBookInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BorrowBookInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.BorrowBookInfo";
  }
  protected:
  explicit BorrowBookInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsbnCodeFieldNumber = 2,
    kBookIdFieldNumber = 1,
    kBorrowTimeFieldNumber = 4,
    kPlanGiveBackTimeFieldNumber = 5,
    kRealGiveBackTimeFieldNumber = 6,
    kReturnBackCountFieldNumber = 7,
    kSubOrderIdFieldNumber = 8,
    kBorrowCountFieldNumber = 3,
  };
  // string IsbnCode = 2;
  void clear_isbncode();
  const std::string& isbncode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_isbncode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_isbncode();
  PROTOBUF_NODISCARD std::string* release_isbncode();
  void set_allocated_isbncode(std::string* isbncode);
  private:
  const std::string& _internal_isbncode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_isbncode(const std::string& value);
  std::string* _internal_mutable_isbncode();
  public:

  // uint64 BookId = 1;
  void clear_bookid();
  uint64_t bookid() const;
  void set_bookid(uint64_t value);
  private:
  uint64_t _internal_bookid() const;
  void _internal_set_bookid(uint64_t value);
  public:

  // sint64 BorrowTime = 4;
  void clear_borrowtime();
  int64_t borrowtime() const;
  void set_borrowtime(int64_t value);
  private:
  int64_t _internal_borrowtime() const;
  void _internal_set_borrowtime(int64_t value);
  public:

  // sint64 PlanGiveBackTime = 5;
  void clear_plangivebacktime();
  int64_t plangivebacktime() const;
  void set_plangivebacktime(int64_t value);
  private:
  int64_t _internal_plangivebacktime() const;
  void _internal_set_plangivebacktime(int64_t value);
  public:

  // sint64 RealGiveBackTime = 6;
  void clear_realgivebacktime();
  int64_t realgivebacktime() const;
  void set_realgivebacktime(int64_t value);
  private:
  int64_t _internal_realgivebacktime() const;
  void _internal_set_realgivebacktime(int64_t value);
  public:

  // uint64 ReturnBackCount = 7;
  void clear_returnbackcount();
  uint64_t returnbackcount() const;
  void set_returnbackcount(uint64_t value);
  private:
  uint64_t _internal_returnbackcount() const;
  void _internal_set_returnbackcount(uint64_t value);
  public:

  // uint64 SubOrderId = 8;
  void clear_suborderid();
  uint64_t suborderid() const;
  void set_suborderid(uint64_t value);
  private:
  uint64_t _internal_suborderid() const;
  void _internal_set_suborderid(uint64_t value);
  public:

  // sint32 BorrowCount = 3;
  void clear_borrowcount();
  int32_t borrowcount() const;
  void set_borrowcount(int32_t value);
  private:
  int32_t _internal_borrowcount() const;
  void _internal_set_borrowcount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.BorrowBookInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr isbncode_;
    uint64_t bookid_;
    int64_t borrowtime_;
    int64_t plangivebacktime_;
    int64_t realgivebacktime_;
    uint64_t returnbackcount_;
    uint64_t suborderid_;
    int32_t borrowcount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class BorrowOrderState final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.BorrowOrderState) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowOrderState failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowOrderState failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowOrderState failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowOrderState failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message BorrowOrderState failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message BorrowOrderState failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline BorrowOrderState() : BorrowOrderState(nullptr) {}
  explicit PROTOBUF_CONSTEXPR BorrowOrderState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BorrowOrderState(const BorrowOrderState& from);
  BorrowOrderState(BorrowOrderState&& from) noexcept
    : BorrowOrderState() {
    *this = ::std::move(from);
  }

  inline BorrowOrderState& operator=(const BorrowOrderState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BorrowOrderState& operator=(BorrowOrderState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BorrowOrderState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BorrowOrderState* internal_default_instance() {
    return reinterpret_cast<const BorrowOrderState*>(
               &_BorrowOrderState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BorrowOrderState& a, BorrowOrderState& b) {
    a.Swap(&b);
  }
  inline void Swap(BorrowOrderState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BorrowOrderState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BorrowOrderState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BorrowOrderState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BorrowOrderState& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BorrowOrderState& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.BorrowOrderState";
  }
  protected:
  explicit BorrowOrderState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BorrowOrderState_ENUMS ENUMS;
  static constexpr ENUMS WAITING_MANAGER_CONFIRM =
    BorrowOrderState_ENUMS_WAITING_MANAGER_CONFIRM;
  static constexpr ENUMS ORDER_CONFIRM =
    BorrowOrderState_ENUMS_ORDER_CONFIRM;
  static constexpr ENUMS WAIT_USER_RECEIVE =
    BorrowOrderState_ENUMS_WAIT_USER_RECEIVE;
  static constexpr ENUMS WAIT_USER_RETURN_BACK =
    BorrowOrderState_ENUMS_WAIT_USER_RETURN_BACK;
  static constexpr ENUMS USER_RETURN_BACK_ALL_BOOKS =
    BorrowOrderState_ENUMS_USER_RETURN_BACK_ALL_BOOKS;
  static constexpr ENUMS CANCEL_ORDER =
    BorrowOrderState_ENUMS_CANCEL_ORDER;
  static constexpr ENUMS RETURN_BAKCK =
    BorrowOrderState_ENUMS_RETURN_BAKCK;
  static inline bool ENUMS_IsValid(int value) {
    return BorrowOrderState_ENUMS_IsValid(value);
  }
  static constexpr ENUMS ENUMS_MIN =
    BorrowOrderState_ENUMS_ENUMS_MIN;
  static constexpr ENUMS ENUMS_MAX =
    BorrowOrderState_ENUMS_ENUMS_MAX;
  static constexpr int ENUMS_ARRAYSIZE =
    BorrowOrderState_ENUMS_ENUMS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ENUMS_descriptor() {
    return BorrowOrderState_ENUMS_descriptor();
  }
  template<typename T>
  static inline const std::string& ENUMS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ENUMS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ENUMS_Name.");
    return BorrowOrderState_ENUMS_Name(enum_t_value);
  }
  static inline bool ENUMS_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ENUMS* value) {
    return BorrowOrderState_ENUMS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.BorrowOrderState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class BorrowOrderInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.BorrowOrderInfo) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowOrderInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowOrderInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowOrderInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message BorrowOrderInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message BorrowOrderInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message BorrowOrderInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline BorrowOrderInfo() : BorrowOrderInfo(nullptr) {}
  ~BorrowOrderInfo() override;
  explicit PROTOBUF_CONSTEXPR BorrowOrderInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BorrowOrderInfo(const BorrowOrderInfo& from);
  BorrowOrderInfo(BorrowOrderInfo&& from) noexcept
    : BorrowOrderInfo() {
    *this = ::std::move(from);
  }

  inline BorrowOrderInfo& operator=(const BorrowOrderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BorrowOrderInfo& operator=(BorrowOrderInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BorrowOrderInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BorrowOrderInfo* internal_default_instance() {
    return reinterpret_cast<const BorrowOrderInfo*>(
               &_BorrowOrderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BorrowOrderInfo& a, BorrowOrderInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BorrowOrderInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BorrowOrderInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BorrowOrderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BorrowOrderInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BorrowOrderInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BorrowOrderInfo& from) {
    BorrowOrderInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BorrowOrderInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.BorrowOrderInfo";
  }
  protected:
  explicit BorrowOrderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBorrowBookListFieldNumber = 2,
    kCancelReasonFieldNumber = 5,
    kOrderIdFieldNumber = 1,
    kCreateOrderTimeFieldNumber = 3,
    kOrderStateFieldNumber = 4,
  };
  // repeated .CRYSTAL_NET.service.BorrowBookInfo BorrowBookList = 2;
  int borrowbooklist_size() const;
  private:
  int _internal_borrowbooklist_size() const;
  public:
  void clear_borrowbooklist();
  ::CRYSTAL_NET::service::BorrowBookInfo* mutable_borrowbooklist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BorrowBookInfo >*
      mutable_borrowbooklist();
  private:
  const ::CRYSTAL_NET::service::BorrowBookInfo& _internal_borrowbooklist(int index) const;
  ::CRYSTAL_NET::service::BorrowBookInfo* _internal_add_borrowbooklist();
  public:
  const ::CRYSTAL_NET::service::BorrowBookInfo& borrowbooklist(int index) const;
  ::CRYSTAL_NET::service::BorrowBookInfo* add_borrowbooklist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BorrowBookInfo >&
      borrowbooklist() const;

  // string CancelReason = 5;
  void clear_cancelreason();
  const std::string& cancelreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cancelreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cancelreason();
  PROTOBUF_NODISCARD std::string* release_cancelreason();
  void set_allocated_cancelreason(std::string* cancelreason);
  private:
  const std::string& _internal_cancelreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cancelreason(const std::string& value);
  std::string* _internal_mutable_cancelreason();
  public:

  // uint64 OrderId = 1;
  void clear_orderid();
  uint64_t orderid() const;
  void set_orderid(uint64_t value);
  private:
  uint64_t _internal_orderid() const;
  void _internal_set_orderid(uint64_t value);
  public:

  // uint64 CreateOrderTime = 3;
  void clear_createordertime();
  uint64_t createordertime() const;
  void set_createordertime(uint64_t value);
  private:
  uint64_t _internal_createordertime() const;
  void _internal_set_createordertime(uint64_t value);
  public:

  // sint32 OrderState = 4;
  void clear_orderstate();
  int32_t orderstate() const;
  void set_orderstate(int32_t value);
  private:
  int32_t _internal_orderstate() const;
  void _internal_set_orderstate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.BorrowOrderInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BorrowBookInfo > borrowbooklist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cancelreason_;
    uint64_t orderid_;
    uint64_t createordertime_;
    int32_t orderstate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class MemberInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.MemberInfo) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message MemberInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message MemberInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message MemberInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message MemberInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message MemberInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message MemberInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline MemberInfo() : MemberInfo(nullptr) {}
  ~MemberInfo() override;
  explicit PROTOBUF_CONSTEXPR MemberInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberInfo(const MemberInfo& from);
  MemberInfo(MemberInfo&& from) noexcept
    : MemberInfo() {
    *this = ::std::move(from);
  }

  inline MemberInfo& operator=(const MemberInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberInfo& operator=(MemberInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberInfo& default_instance() {
    return *internal_default_instance();
  }
  enum MemberBindPhoneCase {
    kBindPhone = 6,
    MEMBERBINDPHONE_NOT_SET = 0,
  };

  static inline const MemberInfo* internal_default_instance() {
    return reinterpret_cast<const MemberInfo*>(
               &_MemberInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MemberInfo& a, MemberInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemberInfo& from) {
    MemberInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.MemberInfo";
  }
  protected:
  explicit MemberInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBorrowListFieldNumber = 4,
    kNicknameFieldNumber = 3,
    kUserIdFieldNumber = 1,
    kLockTimestampMsFieldNumber = 5,
    kRoleFieldNumber = 2,
    kBindPhoneFieldNumber = 6,
  };
  // repeated .CRYSTAL_NET.service.BorrowOrderInfo BorrowList = 4;
  int borrowlist_size() const;
  private:
  int _internal_borrowlist_size() const;
  public:
  void clear_borrowlist();
  ::CRYSTAL_NET::service::BorrowOrderInfo* mutable_borrowlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BorrowOrderInfo >*
      mutable_borrowlist();
  private:
  const ::CRYSTAL_NET::service::BorrowOrderInfo& _internal_borrowlist(int index) const;
  ::CRYSTAL_NET::service::BorrowOrderInfo* _internal_add_borrowlist();
  public:
  const ::CRYSTAL_NET::service::BorrowOrderInfo& borrowlist(int index) const;
  ::CRYSTAL_NET::service::BorrowOrderInfo* add_borrowlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BorrowOrderInfo >&
      borrowlist() const;

  // string Nickname = 3;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // uint64 UserId = 1;
  void clear_userid();
  uint64_t userid() const;
  void set_userid(uint64_t value);
  private:
  uint64_t _internal_userid() const;
  void _internal_set_userid(uint64_t value);
  public:

  // sint64 LockTimestampMs = 5;
  void clear_locktimestampms();
  int64_t locktimestampms() const;
  void set_locktimestampms(int64_t value);
  private:
  int64_t _internal_locktimestampms() const;
  void _internal_set_locktimestampms(int64_t value);
  public:

  // sint32 Role = 2;
  void clear_role();
  int32_t role() const;
  void set_role(int32_t value);
  private:
  int32_t _internal_role() const;
  void _internal_set_role(int32_t value);
  public:

  // uint64 BindPhone = 6;
  bool has_bindphone() const;
  private:
  bool _internal_has_bindphone() const;
  public:
  void clear_bindphone();
  uint64_t bindphone() const;
  void set_bindphone(uint64_t value);
  private:
  uint64_t _internal_bindphone() const;
  void _internal_set_bindphone(uint64_t value);
  public:

  void clear_MemberBindPhone();
  MemberBindPhoneCase MemberBindPhone_case() const;
  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.MemberInfo)
 private:
  class _Internal;
  void set_has_bindphone();

  inline bool has_MemberBindPhone() const;
  inline void clear_has_MemberBindPhone();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BorrowOrderInfo > borrowlist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    uint64_t userid_;
    int64_t locktimestampms_;
    int32_t role_;
    union MemberBindPhoneUnion {
      constexpr MemberBindPhoneUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t bindphone_;
    } MemberBindPhone_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class OperationType final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.OperationType) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message OperationType failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message OperationType failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message OperationType failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message OperationType failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message OperationType failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message OperationType failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline OperationType() : OperationType(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OperationType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationType(const OperationType& from);
  OperationType(OperationType&& from) noexcept
    : OperationType() {
    *this = ::std::move(from);
  }

  inline OperationType& operator=(const OperationType& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationType& operator=(OperationType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationType& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationType* internal_default_instance() {
    return reinterpret_cast<const OperationType*>(
               &_OperationType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OperationType& a, OperationType& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OperationType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OperationType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.OperationType";
  }
  protected:
  explicit OperationType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OperationType_ENUMS ENUMS;
  static constexpr ENUMS UNKNOWN =
    OperationType_ENUMS_UNKNOWN;
  static inline bool ENUMS_IsValid(int value) {
    return OperationType_ENUMS_IsValid(value);
  }
  static constexpr ENUMS ENUMS_MIN =
    OperationType_ENUMS_ENUMS_MIN;
  static constexpr ENUMS ENUMS_MAX =
    OperationType_ENUMS_ENUMS_MAX;
  static constexpr int ENUMS_ARRAYSIZE =
    OperationType_ENUMS_ENUMS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ENUMS_descriptor() {
    return OperationType_ENUMS_descriptor();
  }
  template<typename T>
  static inline const std::string& ENUMS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ENUMS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ENUMS_Name.");
    return OperationType_ENUMS_Name(enum_t_value);
  }
  static inline bool ENUMS_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ENUMS* value) {
    return OperationType_ENUMS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.OperationType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class OperationLogInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.OperationLogInfo) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message OperationLogInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message OperationLogInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message OperationLogInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message OperationLogInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message OperationLogInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message OperationLogInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline OperationLogInfo() : OperationLogInfo(nullptr) {}
  ~OperationLogInfo() override;
  explicit PROTOBUF_CONSTEXPR OperationLogInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationLogInfo(const OperationLogInfo& from);
  OperationLogInfo(OperationLogInfo&& from) noexcept
    : OperationLogInfo() {
    *this = ::std::move(from);
  }

  inline OperationLogInfo& operator=(const OperationLogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationLogInfo& operator=(OperationLogInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationLogInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationLogInfo* internal_default_instance() {
    return reinterpret_cast<const OperationLogInfo*>(
               &_OperationLogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OperationLogInfo& a, OperationLogInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationLogInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationLogInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationLogInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationLogInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationLogInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationLogInfo& from) {
    OperationLogInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationLogInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.OperationLogInfo";
  }
  protected:
  explicit OperationLogInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 6,
    kOpNicknameFieldNumber = 3,
    kOpUserIdFieldNumber = 2,
    kOpTypeFieldNumber = 1,
    kRoleFieldNumber = 4,
    kOpTimeMsFieldNumber = 5,
  };
  // repeated .CRYSTAL_NET.service.VariantParam Params = 6;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  ::CRYSTAL_NET::service::VariantParam* mutable_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::VariantParam >*
      mutable_params();
  private:
  const ::CRYSTAL_NET::service::VariantParam& _internal_params(int index) const;
  ::CRYSTAL_NET::service::VariantParam* _internal_add_params();
  public:
  const ::CRYSTAL_NET::service::VariantParam& params(int index) const;
  ::CRYSTAL_NET::service::VariantParam* add_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::VariantParam >&
      params() const;

  // string OpNickname = 3;
  void clear_opnickname();
  const std::string& opnickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_opnickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_opnickname();
  PROTOBUF_NODISCARD std::string* release_opnickname();
  void set_allocated_opnickname(std::string* opnickname);
  private:
  const std::string& _internal_opnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_opnickname(const std::string& value);
  std::string* _internal_mutable_opnickname();
  public:

  // uint64 OpUserId = 2;
  void clear_opuserid();
  uint64_t opuserid() const;
  void set_opuserid(uint64_t value);
  private:
  uint64_t _internal_opuserid() const;
  void _internal_set_opuserid(uint64_t value);
  public:

  // sint32 OpType = 1;
  void clear_optype();
  int32_t optype() const;
  void set_optype(int32_t value);
  private:
  int32_t _internal_optype() const;
  void _internal_set_optype(int32_t value);
  public:

  // sint32 Role = 4;
  void clear_role();
  int32_t role() const;
  void set_role(int32_t value);
  private:
  int32_t _internal_role() const;
  void _internal_set_role(int32_t value);
  public:

  // sint64 OpTimeMs = 5;
  void clear_optimems();
  int64_t optimems() const;
  void set_optimems(int64_t value);
  private:
  int64_t _internal_optimems() const;
  void _internal_set_optimems(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.OperationLogInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::VariantParam > params_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opnickname_;
    uint64_t opuserid_;
    int32_t optype_;
    int32_t role_;
    int64_t optimems_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class LibraryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.LibraryInfo) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibraryInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibraryInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibraryInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibraryInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message LibraryInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message LibraryInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline LibraryInfo() : LibraryInfo(nullptr) {}
  ~LibraryInfo() override;
  explicit PROTOBUF_CONSTEXPR LibraryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibraryInfo(const LibraryInfo& from);
  LibraryInfo(LibraryInfo&& from) noexcept
    : LibraryInfo() {
    *this = ::std::move(from);
  }

  inline LibraryInfo& operator=(const LibraryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibraryInfo& operator=(LibraryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibraryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibraryInfo* internal_default_instance() {
    return reinterpret_cast<const LibraryInfo*>(
               &_LibraryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LibraryInfo& a, LibraryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LibraryInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibraryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibraryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibraryInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibraryInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibraryInfo& from) {
    LibraryInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibraryInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.LibraryInfo";
  }
  protected:
  explicit LibraryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManagerInfoListFieldNumber = 8,
    kMemberListFieldNumber = 9,
    kBookListFieldNumber = 10,
    kLogInfoListFieldNumber = 11,
    kNameFieldNumber = 2,
    kAddressFieldNumber = 3,
    kOpenTimeFieldNumber = 4,
    kTelphoneNumberFieldNumber = 5,
    kLibrarianUserNicknameFieldNumber = 7,
    kIdFieldNumber = 1,
    kLibrarianUserIdFieldNumber = 6,
  };
  // repeated .CRYSTAL_NET.service.LibararyManagerInfo ManagerInfoList = 8;
  int managerinfolist_size() const;
  private:
  int _internal_managerinfolist_size() const;
  public:
  void clear_managerinfolist();
  ::CRYSTAL_NET::service::LibararyManagerInfo* mutable_managerinfolist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::LibararyManagerInfo >*
      mutable_managerinfolist();
  private:
  const ::CRYSTAL_NET::service::LibararyManagerInfo& _internal_managerinfolist(int index) const;
  ::CRYSTAL_NET::service::LibararyManagerInfo* _internal_add_managerinfolist();
  public:
  const ::CRYSTAL_NET::service::LibararyManagerInfo& managerinfolist(int index) const;
  ::CRYSTAL_NET::service::LibararyManagerInfo* add_managerinfolist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::LibararyManagerInfo >&
      managerinfolist() const;

  // repeated .CRYSTAL_NET.service.MemberInfo MemberList = 9;
  int memberlist_size() const;
  private:
  int _internal_memberlist_size() const;
  public:
  void clear_memberlist();
  ::CRYSTAL_NET::service::MemberInfo* mutable_memberlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::MemberInfo >*
      mutable_memberlist();
  private:
  const ::CRYSTAL_NET::service::MemberInfo& _internal_memberlist(int index) const;
  ::CRYSTAL_NET::service::MemberInfo* _internal_add_memberlist();
  public:
  const ::CRYSTAL_NET::service::MemberInfo& memberlist(int index) const;
  ::CRYSTAL_NET::service::MemberInfo* add_memberlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::MemberInfo >&
      memberlist() const;

  // repeated .CRYSTAL_NET.service.BookInfo BookList = 10;
  int booklist_size() const;
  private:
  int _internal_booklist_size() const;
  public:
  void clear_booklist();
  ::CRYSTAL_NET::service::BookInfo* mutable_booklist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BookInfo >*
      mutable_booklist();
  private:
  const ::CRYSTAL_NET::service::BookInfo& _internal_booklist(int index) const;
  ::CRYSTAL_NET::service::BookInfo* _internal_add_booklist();
  public:
  const ::CRYSTAL_NET::service::BookInfo& booklist(int index) const;
  ::CRYSTAL_NET::service::BookInfo* add_booklist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BookInfo >&
      booklist() const;

  // repeated .CRYSTAL_NET.service.OperationLogInfo LogInfoList = 11;
  int loginfolist_size() const;
  private:
  int _internal_loginfolist_size() const;
  public:
  void clear_loginfolist();
  ::CRYSTAL_NET::service::OperationLogInfo* mutable_loginfolist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::OperationLogInfo >*
      mutable_loginfolist();
  private:
  const ::CRYSTAL_NET::service::OperationLogInfo& _internal_loginfolist(int index) const;
  ::CRYSTAL_NET::service::OperationLogInfo* _internal_add_loginfolist();
  public:
  const ::CRYSTAL_NET::service::OperationLogInfo& loginfolist(int index) const;
  ::CRYSTAL_NET::service::OperationLogInfo* add_loginfolist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::OperationLogInfo >&
      loginfolist() const;

  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string Address = 3;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string OpenTime = 4;
  void clear_opentime();
  const std::string& opentime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_opentime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_opentime();
  PROTOBUF_NODISCARD std::string* release_opentime();
  void set_allocated_opentime(std::string* opentime);
  private:
  const std::string& _internal_opentime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_opentime(const std::string& value);
  std::string* _internal_mutable_opentime();
  public:

  // string TelphoneNumber = 5;
  void clear_telphonenumber();
  const std::string& telphonenumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_telphonenumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_telphonenumber();
  PROTOBUF_NODISCARD std::string* release_telphonenumber();
  void set_allocated_telphonenumber(std::string* telphonenumber);
  private:
  const std::string& _internal_telphonenumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_telphonenumber(const std::string& value);
  std::string* _internal_mutable_telphonenumber();
  public:

  // string LibrarianUserNickname = 7;
  void clear_librarianusernickname();
  const std::string& librarianusernickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_librarianusernickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_librarianusernickname();
  PROTOBUF_NODISCARD std::string* release_librarianusernickname();
  void set_allocated_librarianusernickname(std::string* librarianusernickname);
  private:
  const std::string& _internal_librarianusernickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_librarianusernickname(const std::string& value);
  std::string* _internal_mutable_librarianusernickname();
  public:

  // uint64 Id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 LibrarianUserId = 6;
  void clear_librarianuserid();
  uint64_t librarianuserid() const;
  void set_librarianuserid(uint64_t value);
  private:
  uint64_t _internal_librarianuserid() const;
  void _internal_set_librarianuserid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.LibraryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::LibararyManagerInfo > managerinfolist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::MemberInfo > memberlist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BookInfo > booklist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::OperationLogInfo > loginfolist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opentime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr telphonenumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr librarianusernickname_;
    uint64_t id_;
    uint64_t librarianuserid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class UserLibraryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.UserLibraryInfo) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message UserLibraryInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message UserLibraryInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message UserLibraryInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message UserLibraryInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message UserLibraryInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message UserLibraryInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline UserLibraryInfo() : UserLibraryInfo(nullptr) {}
  ~UserLibraryInfo() override;
  explicit PROTOBUF_CONSTEXPR UserLibraryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLibraryInfo(const UserLibraryInfo& from);
  UserLibraryInfo(UserLibraryInfo&& from) noexcept
    : UserLibraryInfo() {
    *this = ::std::move(from);
  }

  inline UserLibraryInfo& operator=(const UserLibraryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLibraryInfo& operator=(UserLibraryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLibraryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLibraryInfo* internal_default_instance() {
    return reinterpret_cast<const UserLibraryInfo*>(
               &_UserLibraryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserLibraryInfo& a, UserLibraryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLibraryInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLibraryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLibraryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLibraryInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLibraryInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLibraryInfo& from) {
    UserLibraryInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLibraryInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.UserLibraryInfo";
  }
  protected:
  explicit UserLibraryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLibraryIdFieldNumber = 1,
  };
  // uint64 LibraryId = 1;
  void clear_libraryid();
  uint64_t libraryid() const;
  void set_libraryid(uint64_t value);
  private:
  uint64_t _internal_libraryid() const;
  void _internal_set_libraryid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.UserLibraryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t libraryid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class LibraryPreviewInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.LibraryPreviewInfo) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibraryPreviewInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibraryPreviewInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibraryPreviewInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message LibraryPreviewInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message LibraryPreviewInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message LibraryPreviewInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline LibraryPreviewInfo() : LibraryPreviewInfo(nullptr) {}
  ~LibraryPreviewInfo() override;
  explicit PROTOBUF_CONSTEXPR LibraryPreviewInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibraryPreviewInfo(const LibraryPreviewInfo& from);
  LibraryPreviewInfo(LibraryPreviewInfo&& from) noexcept
    : LibraryPreviewInfo() {
    *this = ::std::move(from);
  }

  inline LibraryPreviewInfo& operator=(const LibraryPreviewInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibraryPreviewInfo& operator=(LibraryPreviewInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibraryPreviewInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibraryPreviewInfo* internal_default_instance() {
    return reinterpret_cast<const LibraryPreviewInfo*>(
               &_LibraryPreviewInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LibraryPreviewInfo& a, LibraryPreviewInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LibraryPreviewInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibraryPreviewInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibraryPreviewInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibraryPreviewInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibraryPreviewInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibraryPreviewInfo& from) {
    LibraryPreviewInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibraryPreviewInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.LibraryPreviewInfo";
  }
  protected:
  explicit LibraryPreviewInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kLibrarianNicknameFieldNumber = 4,
    kIdFieldNumber = 1,
    kLibrarianUserIdFieldNumber = 3,
  };
  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string LibrarianNickname = 4;
  void clear_librariannickname();
  const std::string& librariannickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_librariannickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_librariannickname();
  PROTOBUF_NODISCARD std::string* release_librariannickname();
  void set_allocated_librariannickname(std::string* librariannickname);
  private:
  const std::string& _internal_librariannickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_librariannickname(const std::string& value);
  std::string* _internal_mutable_librariannickname();
  public:

  // uint64 Id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 LibrarianUserId = 3;
  void clear_librarianuserid();
  uint64_t librarianuserid() const;
  void set_librarianuserid(uint64_t value);
  private:
  uint64_t _internal_librarianuserid() const;
  void _internal_set_librarianuserid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.LibraryPreviewInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr librariannickname_;
    uint64_t id_;
    uint64_t librarianuserid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class KeyWordsField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.KeyWordsField) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message KeyWordsField failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message KeyWordsField failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message KeyWordsField failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message KeyWordsField failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message KeyWordsField failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message KeyWordsField failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline KeyWordsField() : KeyWordsField(nullptr) {}
  ~KeyWordsField() override;
  explicit PROTOBUF_CONSTEXPR KeyWordsField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyWordsField(const KeyWordsField& from);
  KeyWordsField(KeyWordsField&& from) noexcept
    : KeyWordsField() {
    *this = ::std::move(from);
  }

  inline KeyWordsField& operator=(const KeyWordsField& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyWordsField& operator=(KeyWordsField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyWordsField& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyWordsField* internal_default_instance() {
    return reinterpret_cast<const KeyWordsField*>(
               &_KeyWordsField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(KeyWordsField& a, KeyWordsField& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyWordsField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyWordsField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyWordsField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyWordsField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyWordsField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyWordsField& from) {
    KeyWordsField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyWordsField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.KeyWordsField";
  }
  protected:
  explicit KeyWordsField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyWordsFieldNumber = 1,
  };
  // repeated string KeyWords = 1;
  int keywords_size() const;
  private:
  int _internal_keywords_size() const;
  public:
  void clear_keywords();
  const std::string& keywords(int index) const;
  std::string* mutable_keywords(int index);
  void set_keywords(int index, const std::string& value);
  void set_keywords(int index, std::string&& value);
  void set_keywords(int index, const char* value);
  void set_keywords(int index, const char* value, size_t size);
  std::string* add_keywords();
  void add_keywords(const std::string& value);
  void add_keywords(std::string&& value);
  void add_keywords(const char* value);
  void add_keywords(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keywords() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keywords();
  private:
  const std::string& _internal_keywords(int index) const;
  std::string* _internal_add_keywords();
  public:

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.KeyWordsField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keywords_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false)]
class SnapshotField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.SnapshotField) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message SnapshotField failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message SnapshotField failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message SnapshotField failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message SnapshotField failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message SnapshotField failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message SnapshotField failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    return true;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this));
        return false;
    }

    return true;
}


 public:
  inline SnapshotField() : SnapshotField(nullptr) {}
  ~SnapshotField() override;
  explicit PROTOBUF_CONSTEXPR SnapshotField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotField(const SnapshotField& from);
  SnapshotField(SnapshotField&& from) noexcept
    : SnapshotField() {
    *this = ::std::move(from);
  }

  inline SnapshotField& operator=(const SnapshotField& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotField& operator=(SnapshotField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotField& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotField* internal_default_instance() {
    return reinterpret_cast<const SnapshotField*>(
               &_SnapshotField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SnapshotField& a, SnapshotField& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotField& from) {
    SnapshotField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.SnapshotField";
  }
  protected:
  explicit SnapshotField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotsFieldNumber = 1,
  };
  // repeated string Snapshots = 1;
  int snapshots_size() const;
  private:
  int _internal_snapshots_size() const;
  public:
  void clear_snapshots();
  const std::string& snapshots(int index) const;
  std::string* mutable_snapshots(int index);
  void set_snapshots(int index, const std::string& value);
  void set_snapshots(int index, std::string&& value);
  void set_snapshots(int index, const char* value);
  void set_snapshots(int index, const char* value, size_t size);
  std::string* add_snapshots();
  void add_snapshots(const std::string& value);
  void add_snapshots(std::string&& value);
  void add_snapshots(const char* value);
  void add_snapshots(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& snapshots() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_snapshots();
  private:
  const std::string& _internal_snapshots(int index) const;
  std::string* _internal_add_snapshots();
  public:

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.SnapshotField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> snapshots_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_5flibrary_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoleType

// -------------------------------------------------------------------

// LibararyManagerInfo

// uint64 UserId = 1;
inline void LibararyManagerInfo::clear_userid() {
  _impl_.userid_ = uint64_t{0u};
}
inline uint64_t LibararyManagerInfo::_internal_userid() const {
  return _impl_.userid_;
}
inline uint64_t LibararyManagerInfo::userid() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibararyManagerInfo.UserId)
  return _internal_userid();
}
inline void LibararyManagerInfo::_internal_set_userid(uint64_t value) {
  
  _impl_.userid_ = value;
}
inline void LibararyManagerInfo::set_userid(uint64_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibararyManagerInfo.UserId)
}

// -------------------------------------------------------------------

// BorrowBookInfo

// uint64 BookId = 1;
inline void BorrowBookInfo::clear_bookid() {
  _impl_.bookid_ = uint64_t{0u};
}
inline uint64_t BorrowBookInfo::_internal_bookid() const {
  return _impl_.bookid_;
}
inline uint64_t BorrowBookInfo::bookid() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowBookInfo.BookId)
  return _internal_bookid();
}
inline void BorrowBookInfo::_internal_set_bookid(uint64_t value) {
  
  _impl_.bookid_ = value;
}
inline void BorrowBookInfo::set_bookid(uint64_t value) {
  _internal_set_bookid(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowBookInfo.BookId)
}

// string IsbnCode = 2;
inline void BorrowBookInfo::clear_isbncode() {
  _impl_.isbncode_.ClearToEmpty();
}
inline const std::string& BorrowBookInfo::isbncode() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowBookInfo.IsbnCode)
  return _internal_isbncode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BorrowBookInfo::set_isbncode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.isbncode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowBookInfo.IsbnCode)
}
inline std::string* BorrowBookInfo::mutable_isbncode() {
  std::string* _s = _internal_mutable_isbncode();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.BorrowBookInfo.IsbnCode)
  return _s;
}
inline const std::string& BorrowBookInfo::_internal_isbncode() const {
  return _impl_.isbncode_.Get();
}
inline void BorrowBookInfo::_internal_set_isbncode(const std::string& value) {
  
  _impl_.isbncode_.Set(value, GetArenaForAllocation());
}
inline std::string* BorrowBookInfo::_internal_mutable_isbncode() {
  
  return _impl_.isbncode_.Mutable(GetArenaForAllocation());
}
inline std::string* BorrowBookInfo::release_isbncode() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.BorrowBookInfo.IsbnCode)
  return _impl_.isbncode_.Release();
}
inline void BorrowBookInfo::set_allocated_isbncode(std::string* isbncode) {
  if (isbncode != nullptr) {
    
  } else {
    
  }
  _impl_.isbncode_.SetAllocated(isbncode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.isbncode_.IsDefault()) {
    _impl_.isbncode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.BorrowBookInfo.IsbnCode)
}

// sint32 BorrowCount = 3;
inline void BorrowBookInfo::clear_borrowcount() {
  _impl_.borrowcount_ = 0;
}
inline int32_t BorrowBookInfo::_internal_borrowcount() const {
  return _impl_.borrowcount_;
}
inline int32_t BorrowBookInfo::borrowcount() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowBookInfo.BorrowCount)
  return _internal_borrowcount();
}
inline void BorrowBookInfo::_internal_set_borrowcount(int32_t value) {
  
  _impl_.borrowcount_ = value;
}
inline void BorrowBookInfo::set_borrowcount(int32_t value) {
  _internal_set_borrowcount(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowBookInfo.BorrowCount)
}

// sint64 BorrowTime = 4;
inline void BorrowBookInfo::clear_borrowtime() {
  _impl_.borrowtime_ = int64_t{0};
}
inline int64_t BorrowBookInfo::_internal_borrowtime() const {
  return _impl_.borrowtime_;
}
inline int64_t BorrowBookInfo::borrowtime() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowBookInfo.BorrowTime)
  return _internal_borrowtime();
}
inline void BorrowBookInfo::_internal_set_borrowtime(int64_t value) {
  
  _impl_.borrowtime_ = value;
}
inline void BorrowBookInfo::set_borrowtime(int64_t value) {
  _internal_set_borrowtime(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowBookInfo.BorrowTime)
}

// sint64 PlanGiveBackTime = 5;
inline void BorrowBookInfo::clear_plangivebacktime() {
  _impl_.plangivebacktime_ = int64_t{0};
}
inline int64_t BorrowBookInfo::_internal_plangivebacktime() const {
  return _impl_.plangivebacktime_;
}
inline int64_t BorrowBookInfo::plangivebacktime() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowBookInfo.PlanGiveBackTime)
  return _internal_plangivebacktime();
}
inline void BorrowBookInfo::_internal_set_plangivebacktime(int64_t value) {
  
  _impl_.plangivebacktime_ = value;
}
inline void BorrowBookInfo::set_plangivebacktime(int64_t value) {
  _internal_set_plangivebacktime(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowBookInfo.PlanGiveBackTime)
}

// sint64 RealGiveBackTime = 6;
inline void BorrowBookInfo::clear_realgivebacktime() {
  _impl_.realgivebacktime_ = int64_t{0};
}
inline int64_t BorrowBookInfo::_internal_realgivebacktime() const {
  return _impl_.realgivebacktime_;
}
inline int64_t BorrowBookInfo::realgivebacktime() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowBookInfo.RealGiveBackTime)
  return _internal_realgivebacktime();
}
inline void BorrowBookInfo::_internal_set_realgivebacktime(int64_t value) {
  
  _impl_.realgivebacktime_ = value;
}
inline void BorrowBookInfo::set_realgivebacktime(int64_t value) {
  _internal_set_realgivebacktime(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowBookInfo.RealGiveBackTime)
}

// uint64 ReturnBackCount = 7;
inline void BorrowBookInfo::clear_returnbackcount() {
  _impl_.returnbackcount_ = uint64_t{0u};
}
inline uint64_t BorrowBookInfo::_internal_returnbackcount() const {
  return _impl_.returnbackcount_;
}
inline uint64_t BorrowBookInfo::returnbackcount() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowBookInfo.ReturnBackCount)
  return _internal_returnbackcount();
}
inline void BorrowBookInfo::_internal_set_returnbackcount(uint64_t value) {
  
  _impl_.returnbackcount_ = value;
}
inline void BorrowBookInfo::set_returnbackcount(uint64_t value) {
  _internal_set_returnbackcount(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowBookInfo.ReturnBackCount)
}

// uint64 SubOrderId = 8;
inline void BorrowBookInfo::clear_suborderid() {
  _impl_.suborderid_ = uint64_t{0u};
}
inline uint64_t BorrowBookInfo::_internal_suborderid() const {
  return _impl_.suborderid_;
}
inline uint64_t BorrowBookInfo::suborderid() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowBookInfo.SubOrderId)
  return _internal_suborderid();
}
inline void BorrowBookInfo::_internal_set_suborderid(uint64_t value) {
  
  _impl_.suborderid_ = value;
}
inline void BorrowBookInfo::set_suborderid(uint64_t value) {
  _internal_set_suborderid(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowBookInfo.SubOrderId)
}

// -------------------------------------------------------------------

// BorrowOrderState

// -------------------------------------------------------------------

// BorrowOrderInfo

// uint64 OrderId = 1;
inline void BorrowOrderInfo::clear_orderid() {
  _impl_.orderid_ = uint64_t{0u};
}
inline uint64_t BorrowOrderInfo::_internal_orderid() const {
  return _impl_.orderid_;
}
inline uint64_t BorrowOrderInfo::orderid() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowOrderInfo.OrderId)
  return _internal_orderid();
}
inline void BorrowOrderInfo::_internal_set_orderid(uint64_t value) {
  
  _impl_.orderid_ = value;
}
inline void BorrowOrderInfo::set_orderid(uint64_t value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowOrderInfo.OrderId)
}

// repeated .CRYSTAL_NET.service.BorrowBookInfo BorrowBookList = 2;
inline int BorrowOrderInfo::_internal_borrowbooklist_size() const {
  return _impl_.borrowbooklist_.size();
}
inline int BorrowOrderInfo::borrowbooklist_size() const {
  return _internal_borrowbooklist_size();
}
inline void BorrowOrderInfo::clear_borrowbooklist() {
  _impl_.borrowbooklist_.Clear();
}
inline ::CRYSTAL_NET::service::BorrowBookInfo* BorrowOrderInfo::mutable_borrowbooklist(int index) {
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.BorrowOrderInfo.BorrowBookList)
  return _impl_.borrowbooklist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BorrowBookInfo >*
BorrowOrderInfo::mutable_borrowbooklist() {
  // @@protoc_insertion_point(field_mutable_list:CRYSTAL_NET.service.BorrowOrderInfo.BorrowBookList)
  return &_impl_.borrowbooklist_;
}
inline const ::CRYSTAL_NET::service::BorrowBookInfo& BorrowOrderInfo::_internal_borrowbooklist(int index) const {
  return _impl_.borrowbooklist_.Get(index);
}
inline const ::CRYSTAL_NET::service::BorrowBookInfo& BorrowOrderInfo::borrowbooklist(int index) const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowOrderInfo.BorrowBookList)
  return _internal_borrowbooklist(index);
}
inline ::CRYSTAL_NET::service::BorrowBookInfo* BorrowOrderInfo::_internal_add_borrowbooklist() {
  return _impl_.borrowbooklist_.Add();
}
inline ::CRYSTAL_NET::service::BorrowBookInfo* BorrowOrderInfo::add_borrowbooklist() {
  ::CRYSTAL_NET::service::BorrowBookInfo* _add = _internal_add_borrowbooklist();
  // @@protoc_insertion_point(field_add:CRYSTAL_NET.service.BorrowOrderInfo.BorrowBookList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BorrowBookInfo >&
BorrowOrderInfo::borrowbooklist() const {
  // @@protoc_insertion_point(field_list:CRYSTAL_NET.service.BorrowOrderInfo.BorrowBookList)
  return _impl_.borrowbooklist_;
}

// uint64 CreateOrderTime = 3;
inline void BorrowOrderInfo::clear_createordertime() {
  _impl_.createordertime_ = uint64_t{0u};
}
inline uint64_t BorrowOrderInfo::_internal_createordertime() const {
  return _impl_.createordertime_;
}
inline uint64_t BorrowOrderInfo::createordertime() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowOrderInfo.CreateOrderTime)
  return _internal_createordertime();
}
inline void BorrowOrderInfo::_internal_set_createordertime(uint64_t value) {
  
  _impl_.createordertime_ = value;
}
inline void BorrowOrderInfo::set_createordertime(uint64_t value) {
  _internal_set_createordertime(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowOrderInfo.CreateOrderTime)
}

// sint32 OrderState = 4;
inline void BorrowOrderInfo::clear_orderstate() {
  _impl_.orderstate_ = 0;
}
inline int32_t BorrowOrderInfo::_internal_orderstate() const {
  return _impl_.orderstate_;
}
inline int32_t BorrowOrderInfo::orderstate() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowOrderInfo.OrderState)
  return _internal_orderstate();
}
inline void BorrowOrderInfo::_internal_set_orderstate(int32_t value) {
  
  _impl_.orderstate_ = value;
}
inline void BorrowOrderInfo::set_orderstate(int32_t value) {
  _internal_set_orderstate(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowOrderInfo.OrderState)
}

// string CancelReason = 5;
inline void BorrowOrderInfo::clear_cancelreason() {
  _impl_.cancelreason_.ClearToEmpty();
}
inline const std::string& BorrowOrderInfo::cancelreason() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.BorrowOrderInfo.CancelReason)
  return _internal_cancelreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BorrowOrderInfo::set_cancelreason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cancelreason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.BorrowOrderInfo.CancelReason)
}
inline std::string* BorrowOrderInfo::mutable_cancelreason() {
  std::string* _s = _internal_mutable_cancelreason();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.BorrowOrderInfo.CancelReason)
  return _s;
}
inline const std::string& BorrowOrderInfo::_internal_cancelreason() const {
  return _impl_.cancelreason_.Get();
}
inline void BorrowOrderInfo::_internal_set_cancelreason(const std::string& value) {
  
  _impl_.cancelreason_.Set(value, GetArenaForAllocation());
}
inline std::string* BorrowOrderInfo::_internal_mutable_cancelreason() {
  
  return _impl_.cancelreason_.Mutable(GetArenaForAllocation());
}
inline std::string* BorrowOrderInfo::release_cancelreason() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.BorrowOrderInfo.CancelReason)
  return _impl_.cancelreason_.Release();
}
inline void BorrowOrderInfo::set_allocated_cancelreason(std::string* cancelreason) {
  if (cancelreason != nullptr) {
    
  } else {
    
  }
  _impl_.cancelreason_.SetAllocated(cancelreason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cancelreason_.IsDefault()) {
    _impl_.cancelreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.BorrowOrderInfo.CancelReason)
}

// -------------------------------------------------------------------

// MemberInfo

// uint64 UserId = 1;
inline void MemberInfo::clear_userid() {
  _impl_.userid_ = uint64_t{0u};
}
inline uint64_t MemberInfo::_internal_userid() const {
  return _impl_.userid_;
}
inline uint64_t MemberInfo::userid() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.MemberInfo.UserId)
  return _internal_userid();
}
inline void MemberInfo::_internal_set_userid(uint64_t value) {
  
  _impl_.userid_ = value;
}
inline void MemberInfo::set_userid(uint64_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.MemberInfo.UserId)
}

// sint32 Role = 2;
inline void MemberInfo::clear_role() {
  _impl_.role_ = 0;
}
inline int32_t MemberInfo::_internal_role() const {
  return _impl_.role_;
}
inline int32_t MemberInfo::role() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.MemberInfo.Role)
  return _internal_role();
}
inline void MemberInfo::_internal_set_role(int32_t value) {
  
  _impl_.role_ = value;
}
inline void MemberInfo::set_role(int32_t value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.MemberInfo.Role)
}

// string Nickname = 3;
inline void MemberInfo::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& MemberInfo::nickname() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.MemberInfo.Nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MemberInfo::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.MemberInfo.Nickname)
}
inline std::string* MemberInfo::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.MemberInfo.Nickname)
  return _s;
}
inline const std::string& MemberInfo::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void MemberInfo::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* MemberInfo::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* MemberInfo::release_nickname() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.MemberInfo.Nickname)
  return _impl_.nickname_.Release();
}
inline void MemberInfo::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.MemberInfo.Nickname)
}

// repeated .CRYSTAL_NET.service.BorrowOrderInfo BorrowList = 4;
inline int MemberInfo::_internal_borrowlist_size() const {
  return _impl_.borrowlist_.size();
}
inline int MemberInfo::borrowlist_size() const {
  return _internal_borrowlist_size();
}
inline void MemberInfo::clear_borrowlist() {
  _impl_.borrowlist_.Clear();
}
inline ::CRYSTAL_NET::service::BorrowOrderInfo* MemberInfo::mutable_borrowlist(int index) {
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.MemberInfo.BorrowList)
  return _impl_.borrowlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BorrowOrderInfo >*
MemberInfo::mutable_borrowlist() {
  // @@protoc_insertion_point(field_mutable_list:CRYSTAL_NET.service.MemberInfo.BorrowList)
  return &_impl_.borrowlist_;
}
inline const ::CRYSTAL_NET::service::BorrowOrderInfo& MemberInfo::_internal_borrowlist(int index) const {
  return _impl_.borrowlist_.Get(index);
}
inline const ::CRYSTAL_NET::service::BorrowOrderInfo& MemberInfo::borrowlist(int index) const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.MemberInfo.BorrowList)
  return _internal_borrowlist(index);
}
inline ::CRYSTAL_NET::service::BorrowOrderInfo* MemberInfo::_internal_add_borrowlist() {
  return _impl_.borrowlist_.Add();
}
inline ::CRYSTAL_NET::service::BorrowOrderInfo* MemberInfo::add_borrowlist() {
  ::CRYSTAL_NET::service::BorrowOrderInfo* _add = _internal_add_borrowlist();
  // @@protoc_insertion_point(field_add:CRYSTAL_NET.service.MemberInfo.BorrowList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BorrowOrderInfo >&
MemberInfo::borrowlist() const {
  // @@protoc_insertion_point(field_list:CRYSTAL_NET.service.MemberInfo.BorrowList)
  return _impl_.borrowlist_;
}

// sint64 LockTimestampMs = 5;
inline void MemberInfo::clear_locktimestampms() {
  _impl_.locktimestampms_ = int64_t{0};
}
inline int64_t MemberInfo::_internal_locktimestampms() const {
  return _impl_.locktimestampms_;
}
inline int64_t MemberInfo::locktimestampms() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.MemberInfo.LockTimestampMs)
  return _internal_locktimestampms();
}
inline void MemberInfo::_internal_set_locktimestampms(int64_t value) {
  
  _impl_.locktimestampms_ = value;
}
inline void MemberInfo::set_locktimestampms(int64_t value) {
  _internal_set_locktimestampms(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.MemberInfo.LockTimestampMs)
}

// uint64 BindPhone = 6;
inline bool MemberInfo::_internal_has_bindphone() const {
  return MemberBindPhone_case() == kBindPhone;
}
inline bool MemberInfo::has_bindphone() const {
  return _internal_has_bindphone();
}
inline void MemberInfo::set_has_bindphone() {
  _impl_._oneof_case_[0] = kBindPhone;
}
inline void MemberInfo::clear_bindphone() {
  if (_internal_has_bindphone()) {
    _impl_.MemberBindPhone_.bindphone_ = uint64_t{0u};
    clear_has_MemberBindPhone();
  }
}
inline uint64_t MemberInfo::_internal_bindphone() const {
  if (_internal_has_bindphone()) {
    return _impl_.MemberBindPhone_.bindphone_;
  }
  return uint64_t{0u};
}
inline void MemberInfo::_internal_set_bindphone(uint64_t value) {
  if (!_internal_has_bindphone()) {
    clear_MemberBindPhone();
    set_has_bindphone();
  }
  _impl_.MemberBindPhone_.bindphone_ = value;
}
inline uint64_t MemberInfo::bindphone() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.MemberInfo.BindPhone)
  return _internal_bindphone();
}
inline void MemberInfo::set_bindphone(uint64_t value) {
  _internal_set_bindphone(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.MemberInfo.BindPhone)
}

inline bool MemberInfo::has_MemberBindPhone() const {
  return MemberBindPhone_case() != MEMBERBINDPHONE_NOT_SET;
}
inline void MemberInfo::clear_has_MemberBindPhone() {
  _impl_._oneof_case_[0] = MEMBERBINDPHONE_NOT_SET;
}
inline MemberInfo::MemberBindPhoneCase MemberInfo::MemberBindPhone_case() const {
  return MemberInfo::MemberBindPhoneCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OperationType

// -------------------------------------------------------------------

// OperationLogInfo

// sint32 OpType = 1;
inline void OperationLogInfo::clear_optype() {
  _impl_.optype_ = 0;
}
inline int32_t OperationLogInfo::_internal_optype() const {
  return _impl_.optype_;
}
inline int32_t OperationLogInfo::optype() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.OperationLogInfo.OpType)
  return _internal_optype();
}
inline void OperationLogInfo::_internal_set_optype(int32_t value) {
  
  _impl_.optype_ = value;
}
inline void OperationLogInfo::set_optype(int32_t value) {
  _internal_set_optype(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.OperationLogInfo.OpType)
}

// uint64 OpUserId = 2;
inline void OperationLogInfo::clear_opuserid() {
  _impl_.opuserid_ = uint64_t{0u};
}
inline uint64_t OperationLogInfo::_internal_opuserid() const {
  return _impl_.opuserid_;
}
inline uint64_t OperationLogInfo::opuserid() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.OperationLogInfo.OpUserId)
  return _internal_opuserid();
}
inline void OperationLogInfo::_internal_set_opuserid(uint64_t value) {
  
  _impl_.opuserid_ = value;
}
inline void OperationLogInfo::set_opuserid(uint64_t value) {
  _internal_set_opuserid(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.OperationLogInfo.OpUserId)
}

// string OpNickname = 3;
inline void OperationLogInfo::clear_opnickname() {
  _impl_.opnickname_.ClearToEmpty();
}
inline const std::string& OperationLogInfo::opnickname() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.OperationLogInfo.OpNickname)
  return _internal_opnickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationLogInfo::set_opnickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.opnickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.OperationLogInfo.OpNickname)
}
inline std::string* OperationLogInfo::mutable_opnickname() {
  std::string* _s = _internal_mutable_opnickname();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.OperationLogInfo.OpNickname)
  return _s;
}
inline const std::string& OperationLogInfo::_internal_opnickname() const {
  return _impl_.opnickname_.Get();
}
inline void OperationLogInfo::_internal_set_opnickname(const std::string& value) {
  
  _impl_.opnickname_.Set(value, GetArenaForAllocation());
}
inline std::string* OperationLogInfo::_internal_mutable_opnickname() {
  
  return _impl_.opnickname_.Mutable(GetArenaForAllocation());
}
inline std::string* OperationLogInfo::release_opnickname() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.OperationLogInfo.OpNickname)
  return _impl_.opnickname_.Release();
}
inline void OperationLogInfo::set_allocated_opnickname(std::string* opnickname) {
  if (opnickname != nullptr) {
    
  } else {
    
  }
  _impl_.opnickname_.SetAllocated(opnickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.opnickname_.IsDefault()) {
    _impl_.opnickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.OperationLogInfo.OpNickname)
}

// sint32 Role = 4;
inline void OperationLogInfo::clear_role() {
  _impl_.role_ = 0;
}
inline int32_t OperationLogInfo::_internal_role() const {
  return _impl_.role_;
}
inline int32_t OperationLogInfo::role() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.OperationLogInfo.Role)
  return _internal_role();
}
inline void OperationLogInfo::_internal_set_role(int32_t value) {
  
  _impl_.role_ = value;
}
inline void OperationLogInfo::set_role(int32_t value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.OperationLogInfo.Role)
}

// sint64 OpTimeMs = 5;
inline void OperationLogInfo::clear_optimems() {
  _impl_.optimems_ = int64_t{0};
}
inline int64_t OperationLogInfo::_internal_optimems() const {
  return _impl_.optimems_;
}
inline int64_t OperationLogInfo::optimems() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.OperationLogInfo.OpTimeMs)
  return _internal_optimems();
}
inline void OperationLogInfo::_internal_set_optimems(int64_t value) {
  
  _impl_.optimems_ = value;
}
inline void OperationLogInfo::set_optimems(int64_t value) {
  _internal_set_optimems(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.OperationLogInfo.OpTimeMs)
}

// repeated .CRYSTAL_NET.service.VariantParam Params = 6;
inline int OperationLogInfo::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int OperationLogInfo::params_size() const {
  return _internal_params_size();
}
inline ::CRYSTAL_NET::service::VariantParam* OperationLogInfo::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.OperationLogInfo.Params)
  return _impl_.params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::VariantParam >*
OperationLogInfo::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:CRYSTAL_NET.service.OperationLogInfo.Params)
  return &_impl_.params_;
}
inline const ::CRYSTAL_NET::service::VariantParam& OperationLogInfo::_internal_params(int index) const {
  return _impl_.params_.Get(index);
}
inline const ::CRYSTAL_NET::service::VariantParam& OperationLogInfo::params(int index) const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.OperationLogInfo.Params)
  return _internal_params(index);
}
inline ::CRYSTAL_NET::service::VariantParam* OperationLogInfo::_internal_add_params() {
  return _impl_.params_.Add();
}
inline ::CRYSTAL_NET::service::VariantParam* OperationLogInfo::add_params() {
  ::CRYSTAL_NET::service::VariantParam* _add = _internal_add_params();
  // @@protoc_insertion_point(field_add:CRYSTAL_NET.service.OperationLogInfo.Params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::VariantParam >&
OperationLogInfo::params() const {
  // @@protoc_insertion_point(field_list:CRYSTAL_NET.service.OperationLogInfo.Params)
  return _impl_.params_;
}

// -------------------------------------------------------------------

// LibraryInfo

// uint64 Id = 1;
inline void LibraryInfo::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t LibraryInfo::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibraryInfo::id() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryInfo.Id)
  return _internal_id();
}
inline void LibraryInfo::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void LibraryInfo::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibraryInfo.Id)
}

// string Name = 2;
inline void LibraryInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LibraryInfo::name() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryInfo.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibraryInfo.Name)
}
inline std::string* LibraryInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.LibraryInfo.Name)
  return _s;
}
inline const std::string& LibraryInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LibraryInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibraryInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibraryInfo::release_name() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.LibraryInfo.Name)
  return _impl_.name_.Release();
}
inline void LibraryInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.LibraryInfo.Name)
}

// string Address = 3;
inline void LibraryInfo::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& LibraryInfo::address() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryInfo.Address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryInfo::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibraryInfo.Address)
}
inline std::string* LibraryInfo::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.LibraryInfo.Address)
  return _s;
}
inline const std::string& LibraryInfo::_internal_address() const {
  return _impl_.address_.Get();
}
inline void LibraryInfo::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* LibraryInfo::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* LibraryInfo::release_address() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.LibraryInfo.Address)
  return _impl_.address_.Release();
}
inline void LibraryInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.LibraryInfo.Address)
}

// string OpenTime = 4;
inline void LibraryInfo::clear_opentime() {
  _impl_.opentime_.ClearToEmpty();
}
inline const std::string& LibraryInfo::opentime() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryInfo.OpenTime)
  return _internal_opentime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryInfo::set_opentime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.opentime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibraryInfo.OpenTime)
}
inline std::string* LibraryInfo::mutable_opentime() {
  std::string* _s = _internal_mutable_opentime();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.LibraryInfo.OpenTime)
  return _s;
}
inline const std::string& LibraryInfo::_internal_opentime() const {
  return _impl_.opentime_.Get();
}
inline void LibraryInfo::_internal_set_opentime(const std::string& value) {
  
  _impl_.opentime_.Set(value, GetArenaForAllocation());
}
inline std::string* LibraryInfo::_internal_mutable_opentime() {
  
  return _impl_.opentime_.Mutable(GetArenaForAllocation());
}
inline std::string* LibraryInfo::release_opentime() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.LibraryInfo.OpenTime)
  return _impl_.opentime_.Release();
}
inline void LibraryInfo::set_allocated_opentime(std::string* opentime) {
  if (opentime != nullptr) {
    
  } else {
    
  }
  _impl_.opentime_.SetAllocated(opentime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.opentime_.IsDefault()) {
    _impl_.opentime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.LibraryInfo.OpenTime)
}

// string TelphoneNumber = 5;
inline void LibraryInfo::clear_telphonenumber() {
  _impl_.telphonenumber_.ClearToEmpty();
}
inline const std::string& LibraryInfo::telphonenumber() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryInfo.TelphoneNumber)
  return _internal_telphonenumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryInfo::set_telphonenumber(ArgT0&& arg0, ArgT... args) {
 
 _impl_.telphonenumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibraryInfo.TelphoneNumber)
}
inline std::string* LibraryInfo::mutable_telphonenumber() {
  std::string* _s = _internal_mutable_telphonenumber();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.LibraryInfo.TelphoneNumber)
  return _s;
}
inline const std::string& LibraryInfo::_internal_telphonenumber() const {
  return _impl_.telphonenumber_.Get();
}
inline void LibraryInfo::_internal_set_telphonenumber(const std::string& value) {
  
  _impl_.telphonenumber_.Set(value, GetArenaForAllocation());
}
inline std::string* LibraryInfo::_internal_mutable_telphonenumber() {
  
  return _impl_.telphonenumber_.Mutable(GetArenaForAllocation());
}
inline std::string* LibraryInfo::release_telphonenumber() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.LibraryInfo.TelphoneNumber)
  return _impl_.telphonenumber_.Release();
}
inline void LibraryInfo::set_allocated_telphonenumber(std::string* telphonenumber) {
  if (telphonenumber != nullptr) {
    
  } else {
    
  }
  _impl_.telphonenumber_.SetAllocated(telphonenumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.telphonenumber_.IsDefault()) {
    _impl_.telphonenumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.LibraryInfo.TelphoneNumber)
}

// uint64 LibrarianUserId = 6;
inline void LibraryInfo::clear_librarianuserid() {
  _impl_.librarianuserid_ = uint64_t{0u};
}
inline uint64_t LibraryInfo::_internal_librarianuserid() const {
  return _impl_.librarianuserid_;
}
inline uint64_t LibraryInfo::librarianuserid() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryInfo.LibrarianUserId)
  return _internal_librarianuserid();
}
inline void LibraryInfo::_internal_set_librarianuserid(uint64_t value) {
  
  _impl_.librarianuserid_ = value;
}
inline void LibraryInfo::set_librarianuserid(uint64_t value) {
  _internal_set_librarianuserid(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibraryInfo.LibrarianUserId)
}

// string LibrarianUserNickname = 7;
inline void LibraryInfo::clear_librarianusernickname() {
  _impl_.librarianusernickname_.ClearToEmpty();
}
inline const std::string& LibraryInfo::librarianusernickname() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryInfo.LibrarianUserNickname)
  return _internal_librarianusernickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryInfo::set_librarianusernickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.librarianusernickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibraryInfo.LibrarianUserNickname)
}
inline std::string* LibraryInfo::mutable_librarianusernickname() {
  std::string* _s = _internal_mutable_librarianusernickname();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.LibraryInfo.LibrarianUserNickname)
  return _s;
}
inline const std::string& LibraryInfo::_internal_librarianusernickname() const {
  return _impl_.librarianusernickname_.Get();
}
inline void LibraryInfo::_internal_set_librarianusernickname(const std::string& value) {
  
  _impl_.librarianusernickname_.Set(value, GetArenaForAllocation());
}
inline std::string* LibraryInfo::_internal_mutable_librarianusernickname() {
  
  return _impl_.librarianusernickname_.Mutable(GetArenaForAllocation());
}
inline std::string* LibraryInfo::release_librarianusernickname() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.LibraryInfo.LibrarianUserNickname)
  return _impl_.librarianusernickname_.Release();
}
inline void LibraryInfo::set_allocated_librarianusernickname(std::string* librarianusernickname) {
  if (librarianusernickname != nullptr) {
    
  } else {
    
  }
  _impl_.librarianusernickname_.SetAllocated(librarianusernickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.librarianusernickname_.IsDefault()) {
    _impl_.librarianusernickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.LibraryInfo.LibrarianUserNickname)
}

// repeated .CRYSTAL_NET.service.LibararyManagerInfo ManagerInfoList = 8;
inline int LibraryInfo::_internal_managerinfolist_size() const {
  return _impl_.managerinfolist_.size();
}
inline int LibraryInfo::managerinfolist_size() const {
  return _internal_managerinfolist_size();
}
inline void LibraryInfo::clear_managerinfolist() {
  _impl_.managerinfolist_.Clear();
}
inline ::CRYSTAL_NET::service::LibararyManagerInfo* LibraryInfo::mutable_managerinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.LibraryInfo.ManagerInfoList)
  return _impl_.managerinfolist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::LibararyManagerInfo >*
LibraryInfo::mutable_managerinfolist() {
  // @@protoc_insertion_point(field_mutable_list:CRYSTAL_NET.service.LibraryInfo.ManagerInfoList)
  return &_impl_.managerinfolist_;
}
inline const ::CRYSTAL_NET::service::LibararyManagerInfo& LibraryInfo::_internal_managerinfolist(int index) const {
  return _impl_.managerinfolist_.Get(index);
}
inline const ::CRYSTAL_NET::service::LibararyManagerInfo& LibraryInfo::managerinfolist(int index) const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryInfo.ManagerInfoList)
  return _internal_managerinfolist(index);
}
inline ::CRYSTAL_NET::service::LibararyManagerInfo* LibraryInfo::_internal_add_managerinfolist() {
  return _impl_.managerinfolist_.Add();
}
inline ::CRYSTAL_NET::service::LibararyManagerInfo* LibraryInfo::add_managerinfolist() {
  ::CRYSTAL_NET::service::LibararyManagerInfo* _add = _internal_add_managerinfolist();
  // @@protoc_insertion_point(field_add:CRYSTAL_NET.service.LibraryInfo.ManagerInfoList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::LibararyManagerInfo >&
LibraryInfo::managerinfolist() const {
  // @@protoc_insertion_point(field_list:CRYSTAL_NET.service.LibraryInfo.ManagerInfoList)
  return _impl_.managerinfolist_;
}

// repeated .CRYSTAL_NET.service.MemberInfo MemberList = 9;
inline int LibraryInfo::_internal_memberlist_size() const {
  return _impl_.memberlist_.size();
}
inline int LibraryInfo::memberlist_size() const {
  return _internal_memberlist_size();
}
inline void LibraryInfo::clear_memberlist() {
  _impl_.memberlist_.Clear();
}
inline ::CRYSTAL_NET::service::MemberInfo* LibraryInfo::mutable_memberlist(int index) {
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.LibraryInfo.MemberList)
  return _impl_.memberlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::MemberInfo >*
LibraryInfo::mutable_memberlist() {
  // @@protoc_insertion_point(field_mutable_list:CRYSTAL_NET.service.LibraryInfo.MemberList)
  return &_impl_.memberlist_;
}
inline const ::CRYSTAL_NET::service::MemberInfo& LibraryInfo::_internal_memberlist(int index) const {
  return _impl_.memberlist_.Get(index);
}
inline const ::CRYSTAL_NET::service::MemberInfo& LibraryInfo::memberlist(int index) const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryInfo.MemberList)
  return _internal_memberlist(index);
}
inline ::CRYSTAL_NET::service::MemberInfo* LibraryInfo::_internal_add_memberlist() {
  return _impl_.memberlist_.Add();
}
inline ::CRYSTAL_NET::service::MemberInfo* LibraryInfo::add_memberlist() {
  ::CRYSTAL_NET::service::MemberInfo* _add = _internal_add_memberlist();
  // @@protoc_insertion_point(field_add:CRYSTAL_NET.service.LibraryInfo.MemberList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::MemberInfo >&
LibraryInfo::memberlist() const {
  // @@protoc_insertion_point(field_list:CRYSTAL_NET.service.LibraryInfo.MemberList)
  return _impl_.memberlist_;
}

// repeated .CRYSTAL_NET.service.BookInfo BookList = 10;
inline int LibraryInfo::_internal_booklist_size() const {
  return _impl_.booklist_.size();
}
inline int LibraryInfo::booklist_size() const {
  return _internal_booklist_size();
}
inline ::CRYSTAL_NET::service::BookInfo* LibraryInfo::mutable_booklist(int index) {
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.LibraryInfo.BookList)
  return _impl_.booklist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BookInfo >*
LibraryInfo::mutable_booklist() {
  // @@protoc_insertion_point(field_mutable_list:CRYSTAL_NET.service.LibraryInfo.BookList)
  return &_impl_.booklist_;
}
inline const ::CRYSTAL_NET::service::BookInfo& LibraryInfo::_internal_booklist(int index) const {
  return _impl_.booklist_.Get(index);
}
inline const ::CRYSTAL_NET::service::BookInfo& LibraryInfo::booklist(int index) const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryInfo.BookList)
  return _internal_booklist(index);
}
inline ::CRYSTAL_NET::service::BookInfo* LibraryInfo::_internal_add_booklist() {
  return _impl_.booklist_.Add();
}
inline ::CRYSTAL_NET::service::BookInfo* LibraryInfo::add_booklist() {
  ::CRYSTAL_NET::service::BookInfo* _add = _internal_add_booklist();
  // @@protoc_insertion_point(field_add:CRYSTAL_NET.service.LibraryInfo.BookList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::BookInfo >&
LibraryInfo::booklist() const {
  // @@protoc_insertion_point(field_list:CRYSTAL_NET.service.LibraryInfo.BookList)
  return _impl_.booklist_;
}

// repeated .CRYSTAL_NET.service.OperationLogInfo LogInfoList = 11;
inline int LibraryInfo::_internal_loginfolist_size() const {
  return _impl_.loginfolist_.size();
}
inline int LibraryInfo::loginfolist_size() const {
  return _internal_loginfolist_size();
}
inline void LibraryInfo::clear_loginfolist() {
  _impl_.loginfolist_.Clear();
}
inline ::CRYSTAL_NET::service::OperationLogInfo* LibraryInfo::mutable_loginfolist(int index) {
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.LibraryInfo.LogInfoList)
  return _impl_.loginfolist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::OperationLogInfo >*
LibraryInfo::mutable_loginfolist() {
  // @@protoc_insertion_point(field_mutable_list:CRYSTAL_NET.service.LibraryInfo.LogInfoList)
  return &_impl_.loginfolist_;
}
inline const ::CRYSTAL_NET::service::OperationLogInfo& LibraryInfo::_internal_loginfolist(int index) const {
  return _impl_.loginfolist_.Get(index);
}
inline const ::CRYSTAL_NET::service::OperationLogInfo& LibraryInfo::loginfolist(int index) const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryInfo.LogInfoList)
  return _internal_loginfolist(index);
}
inline ::CRYSTAL_NET::service::OperationLogInfo* LibraryInfo::_internal_add_loginfolist() {
  return _impl_.loginfolist_.Add();
}
inline ::CRYSTAL_NET::service::OperationLogInfo* LibraryInfo::add_loginfolist() {
  ::CRYSTAL_NET::service::OperationLogInfo* _add = _internal_add_loginfolist();
  // @@protoc_insertion_point(field_add:CRYSTAL_NET.service.LibraryInfo.LogInfoList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRYSTAL_NET::service::OperationLogInfo >&
LibraryInfo::loginfolist() const {
  // @@protoc_insertion_point(field_list:CRYSTAL_NET.service.LibraryInfo.LogInfoList)
  return _impl_.loginfolist_;
}

// -------------------------------------------------------------------

// UserLibraryInfo

// uint64 LibraryId = 1;
inline void UserLibraryInfo::clear_libraryid() {
  _impl_.libraryid_ = uint64_t{0u};
}
inline uint64_t UserLibraryInfo::_internal_libraryid() const {
  return _impl_.libraryid_;
}
inline uint64_t UserLibraryInfo::libraryid() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.UserLibraryInfo.LibraryId)
  return _internal_libraryid();
}
inline void UserLibraryInfo::_internal_set_libraryid(uint64_t value) {
  
  _impl_.libraryid_ = value;
}
inline void UserLibraryInfo::set_libraryid(uint64_t value) {
  _internal_set_libraryid(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.UserLibraryInfo.LibraryId)
}

// -------------------------------------------------------------------

// LibraryPreviewInfo

// uint64 Id = 1;
inline void LibraryPreviewInfo::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t LibraryPreviewInfo::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibraryPreviewInfo::id() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryPreviewInfo.Id)
  return _internal_id();
}
inline void LibraryPreviewInfo::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void LibraryPreviewInfo::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibraryPreviewInfo.Id)
}

// string Name = 2;
inline void LibraryPreviewInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LibraryPreviewInfo::name() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryPreviewInfo.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryPreviewInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibraryPreviewInfo.Name)
}
inline std::string* LibraryPreviewInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.LibraryPreviewInfo.Name)
  return _s;
}
inline const std::string& LibraryPreviewInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LibraryPreviewInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibraryPreviewInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibraryPreviewInfo::release_name() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.LibraryPreviewInfo.Name)
  return _impl_.name_.Release();
}
inline void LibraryPreviewInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.LibraryPreviewInfo.Name)
}

// uint64 LibrarianUserId = 3;
inline void LibraryPreviewInfo::clear_librarianuserid() {
  _impl_.librarianuserid_ = uint64_t{0u};
}
inline uint64_t LibraryPreviewInfo::_internal_librarianuserid() const {
  return _impl_.librarianuserid_;
}
inline uint64_t LibraryPreviewInfo::librarianuserid() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryPreviewInfo.LibrarianUserId)
  return _internal_librarianuserid();
}
inline void LibraryPreviewInfo::_internal_set_librarianuserid(uint64_t value) {
  
  _impl_.librarianuserid_ = value;
}
inline void LibraryPreviewInfo::set_librarianuserid(uint64_t value) {
  _internal_set_librarianuserid(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibraryPreviewInfo.LibrarianUserId)
}

// string LibrarianNickname = 4;
inline void LibraryPreviewInfo::clear_librariannickname() {
  _impl_.librariannickname_.ClearToEmpty();
}
inline const std::string& LibraryPreviewInfo::librariannickname() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.LibraryPreviewInfo.LibrarianNickname)
  return _internal_librariannickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryPreviewInfo::set_librariannickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.librariannickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.LibraryPreviewInfo.LibrarianNickname)
}
inline std::string* LibraryPreviewInfo::mutable_librariannickname() {
  std::string* _s = _internal_mutable_librariannickname();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.LibraryPreviewInfo.LibrarianNickname)
  return _s;
}
inline const std::string& LibraryPreviewInfo::_internal_librariannickname() const {
  return _impl_.librariannickname_.Get();
}
inline void LibraryPreviewInfo::_internal_set_librariannickname(const std::string& value) {
  
  _impl_.librariannickname_.Set(value, GetArenaForAllocation());
}
inline std::string* LibraryPreviewInfo::_internal_mutable_librariannickname() {
  
  return _impl_.librariannickname_.Mutable(GetArenaForAllocation());
}
inline std::string* LibraryPreviewInfo::release_librariannickname() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.LibraryPreviewInfo.LibrarianNickname)
  return _impl_.librariannickname_.Release();
}
inline void LibraryPreviewInfo::set_allocated_librariannickname(std::string* librariannickname) {
  if (librariannickname != nullptr) {
    
  } else {
    
  }
  _impl_.librariannickname_.SetAllocated(librariannickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.librariannickname_.IsDefault()) {
    _impl_.librariannickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.LibraryPreviewInfo.LibrarianNickname)
}

// -------------------------------------------------------------------

// KeyWordsField

// repeated string KeyWords = 1;
inline int KeyWordsField::_internal_keywords_size() const {
  return _impl_.keywords_.size();
}
inline int KeyWordsField::keywords_size() const {
  return _internal_keywords_size();
}
inline void KeyWordsField::clear_keywords() {
  _impl_.keywords_.Clear();
}
inline std::string* KeyWordsField::add_keywords() {
  std::string* _s = _internal_add_keywords();
  // @@protoc_insertion_point(field_add_mutable:CRYSTAL_NET.service.KeyWordsField.KeyWords)
  return _s;
}
inline const std::string& KeyWordsField::_internal_keywords(int index) const {
  return _impl_.keywords_.Get(index);
}
inline const std::string& KeyWordsField::keywords(int index) const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.KeyWordsField.KeyWords)
  return _internal_keywords(index);
}
inline std::string* KeyWordsField::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.KeyWordsField.KeyWords)
  return _impl_.keywords_.Mutable(index);
}
inline void KeyWordsField::set_keywords(int index, const std::string& value) {
  _impl_.keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.KeyWordsField.KeyWords)
}
inline void KeyWordsField::set_keywords(int index, std::string&& value) {
  _impl_.keywords_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.KeyWordsField.KeyWords)
}
inline void KeyWordsField::set_keywords(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CRYSTAL_NET.service.KeyWordsField.KeyWords)
}
inline void KeyWordsField::set_keywords(int index, const char* value, size_t size) {
  _impl_.keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CRYSTAL_NET.service.KeyWordsField.KeyWords)
}
inline std::string* KeyWordsField::_internal_add_keywords() {
  return _impl_.keywords_.Add();
}
inline void KeyWordsField::add_keywords(const std::string& value) {
  _impl_.keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CRYSTAL_NET.service.KeyWordsField.KeyWords)
}
inline void KeyWordsField::add_keywords(std::string&& value) {
  _impl_.keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CRYSTAL_NET.service.KeyWordsField.KeyWords)
}
inline void KeyWordsField::add_keywords(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CRYSTAL_NET.service.KeyWordsField.KeyWords)
}
inline void KeyWordsField::add_keywords(const char* value, size_t size) {
  _impl_.keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CRYSTAL_NET.service.KeyWordsField.KeyWords)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
KeyWordsField::keywords() const {
  // @@protoc_insertion_point(field_list:CRYSTAL_NET.service.KeyWordsField.KeyWords)
  return _impl_.keywords_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
KeyWordsField::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:CRYSTAL_NET.service.KeyWordsField.KeyWords)
  return &_impl_.keywords_;
}

// -------------------------------------------------------------------

// SnapshotField

// repeated string Snapshots = 1;
inline int SnapshotField::_internal_snapshots_size() const {
  return _impl_.snapshots_.size();
}
inline int SnapshotField::snapshots_size() const {
  return _internal_snapshots_size();
}
inline void SnapshotField::clear_snapshots() {
  _impl_.snapshots_.Clear();
}
inline std::string* SnapshotField::add_snapshots() {
  std::string* _s = _internal_add_snapshots();
  // @@protoc_insertion_point(field_add_mutable:CRYSTAL_NET.service.SnapshotField.Snapshots)
  return _s;
}
inline const std::string& SnapshotField::_internal_snapshots(int index) const {
  return _impl_.snapshots_.Get(index);
}
inline const std::string& SnapshotField::snapshots(int index) const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.SnapshotField.Snapshots)
  return _internal_snapshots(index);
}
inline std::string* SnapshotField::mutable_snapshots(int index) {
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.SnapshotField.Snapshots)
  return _impl_.snapshots_.Mutable(index);
}
inline void SnapshotField::set_snapshots(int index, const std::string& value) {
  _impl_.snapshots_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.SnapshotField.Snapshots)
}
inline void SnapshotField::set_snapshots(int index, std::string&& value) {
  _impl_.snapshots_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.SnapshotField.Snapshots)
}
inline void SnapshotField::set_snapshots(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.snapshots_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CRYSTAL_NET.service.SnapshotField.Snapshots)
}
inline void SnapshotField::set_snapshots(int index, const char* value, size_t size) {
  _impl_.snapshots_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CRYSTAL_NET.service.SnapshotField.Snapshots)
}
inline std::string* SnapshotField::_internal_add_snapshots() {
  return _impl_.snapshots_.Add();
}
inline void SnapshotField::add_snapshots(const std::string& value) {
  _impl_.snapshots_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CRYSTAL_NET.service.SnapshotField.Snapshots)
}
inline void SnapshotField::add_snapshots(std::string&& value) {
  _impl_.snapshots_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CRYSTAL_NET.service.SnapshotField.Snapshots)
}
inline void SnapshotField::add_snapshots(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.snapshots_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CRYSTAL_NET.service.SnapshotField.Snapshots)
}
inline void SnapshotField::add_snapshots(const char* value, size_t size) {
  _impl_.snapshots_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CRYSTAL_NET.service.SnapshotField.Snapshots)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SnapshotField::snapshots() const {
  // @@protoc_insertion_point(field_list:CRYSTAL_NET.service.SnapshotField.Snapshots)
  return _impl_.snapshots_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SnapshotField::mutable_snapshots() {
  // @@protoc_insertion_point(field_mutable_list:CRYSTAL_NET.service.SnapshotField.Snapshots)
  return &_impl_.snapshots_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service
}  // namespace CRYSTAL_NET

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CRYSTAL_NET::service::RoleType_ENUMS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CRYSTAL_NET::service::RoleType_ENUMS>() {
  return ::CRYSTAL_NET::service::RoleType_ENUMS_descriptor();
}
template <> struct is_proto_enum< ::CRYSTAL_NET::service::BorrowOrderState_ENUMS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CRYSTAL_NET::service::BorrowOrderState_ENUMS>() {
  return ::CRYSTAL_NET::service::BorrowOrderState_ENUMS_descriptor();
}
template <> struct is_proto_enum< ::CRYSTAL_NET::service::OperationType_ENUMS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CRYSTAL_NET::service::OperationType_ENUMS>() {
  return ::CRYSTAL_NET::service::OperationType_ENUMS_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>

class RoleTypeFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, RoleTypeFactory);
public:

    virtual void Release() override {
        RoleTypeFactory::Delete_RoleTypeFactory(this);
    }

    static RoleTypeFactory *CreateFactory() {
        return RoleTypeFactory::New_RoleTypeFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::RoleType();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::RoleType(*dynamic_cast<const ::CRYSTAL_NET::service::RoleType *>(coder));
    }

};


class LibararyManagerInfoFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, LibararyManagerInfoFactory);
public:

    virtual void Release() override {
        LibararyManagerInfoFactory::Delete_LibararyManagerInfoFactory(this);
    }

    static LibararyManagerInfoFactory *CreateFactory() {
        return LibararyManagerInfoFactory::New_LibararyManagerInfoFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::LibararyManagerInfo();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::LibararyManagerInfo(*dynamic_cast<const ::CRYSTAL_NET::service::LibararyManagerInfo *>(coder));
    }

};


class BorrowBookInfoFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, BorrowBookInfoFactory);
public:

    virtual void Release() override {
        BorrowBookInfoFactory::Delete_BorrowBookInfoFactory(this);
    }

    static BorrowBookInfoFactory *CreateFactory() {
        return BorrowBookInfoFactory::New_BorrowBookInfoFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::BorrowBookInfo();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::BorrowBookInfo(*dynamic_cast<const ::CRYSTAL_NET::service::BorrowBookInfo *>(coder));
    }

};


class BorrowOrderStateFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, BorrowOrderStateFactory);
public:

    virtual void Release() override {
        BorrowOrderStateFactory::Delete_BorrowOrderStateFactory(this);
    }

    static BorrowOrderStateFactory *CreateFactory() {
        return BorrowOrderStateFactory::New_BorrowOrderStateFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::BorrowOrderState();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::BorrowOrderState(*dynamic_cast<const ::CRYSTAL_NET::service::BorrowOrderState *>(coder));
    }

};


class BorrowOrderInfoFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, BorrowOrderInfoFactory);
public:

    virtual void Release() override {
        BorrowOrderInfoFactory::Delete_BorrowOrderInfoFactory(this);
    }

    static BorrowOrderInfoFactory *CreateFactory() {
        return BorrowOrderInfoFactory::New_BorrowOrderInfoFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::BorrowOrderInfo();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::BorrowOrderInfo(*dynamic_cast<const ::CRYSTAL_NET::service::BorrowOrderInfo *>(coder));
    }

};


class MemberInfoFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, MemberInfoFactory);
public:

    virtual void Release() override {
        MemberInfoFactory::Delete_MemberInfoFactory(this);
    }

    static MemberInfoFactory *CreateFactory() {
        return MemberInfoFactory::New_MemberInfoFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::MemberInfo();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::MemberInfo(*dynamic_cast<const ::CRYSTAL_NET::service::MemberInfo *>(coder));
    }

};


class OperationTypeFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, OperationTypeFactory);
public:

    virtual void Release() override {
        OperationTypeFactory::Delete_OperationTypeFactory(this);
    }

    static OperationTypeFactory *CreateFactory() {
        return OperationTypeFactory::New_OperationTypeFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::OperationType();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::OperationType(*dynamic_cast<const ::CRYSTAL_NET::service::OperationType *>(coder));
    }

};


class OperationLogInfoFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, OperationLogInfoFactory);
public:

    virtual void Release() override {
        OperationLogInfoFactory::Delete_OperationLogInfoFactory(this);
    }

    static OperationLogInfoFactory *CreateFactory() {
        return OperationLogInfoFactory::New_OperationLogInfoFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::OperationLogInfo();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::OperationLogInfo(*dynamic_cast<const ::CRYSTAL_NET::service::OperationLogInfo *>(coder));
    }

};


class LibraryInfoFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, LibraryInfoFactory);
public:

    virtual void Release() override {
        LibraryInfoFactory::Delete_LibraryInfoFactory(this);
    }

    static LibraryInfoFactory *CreateFactory() {
        return LibraryInfoFactory::New_LibraryInfoFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::LibraryInfo();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::LibraryInfo(*dynamic_cast<const ::CRYSTAL_NET::service::LibraryInfo *>(coder));
    }

};


class UserLibraryInfoFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, UserLibraryInfoFactory);
public:

    virtual void Release() override {
        UserLibraryInfoFactory::Delete_UserLibraryInfoFactory(this);
    }

    static UserLibraryInfoFactory *CreateFactory() {
        return UserLibraryInfoFactory::New_UserLibraryInfoFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::UserLibraryInfo();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::UserLibraryInfo(*dynamic_cast<const ::CRYSTAL_NET::service::UserLibraryInfo *>(coder));
    }

};


class LibraryPreviewInfoFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, LibraryPreviewInfoFactory);
public:

    virtual void Release() override {
        LibraryPreviewInfoFactory::Delete_LibraryPreviewInfoFactory(this);
    }

    static LibraryPreviewInfoFactory *CreateFactory() {
        return LibraryPreviewInfoFactory::New_LibraryPreviewInfoFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::LibraryPreviewInfo();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::LibraryPreviewInfo(*dynamic_cast<const ::CRYSTAL_NET::service::LibraryPreviewInfo *>(coder));
    }

};


class KeyWordsFieldFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, KeyWordsFieldFactory);
public:

    virtual void Release() override {
        KeyWordsFieldFactory::Delete_KeyWordsFieldFactory(this);
    }

    static KeyWordsFieldFactory *CreateFactory() {
        return KeyWordsFieldFactory::New_KeyWordsFieldFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::KeyWordsField();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::KeyWordsField(*dynamic_cast<const ::CRYSTAL_NET::service::KeyWordsField *>(coder));
    }

};


class SnapshotFieldFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, SnapshotFieldFactory);
public:

    virtual void Release() override {
        SnapshotFieldFactory::Delete_SnapshotFieldFactory(this);
    }

    static SnapshotFieldFactory *CreateFactory() {
        return SnapshotFieldFactory::New_SnapshotFieldFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::SnapshotField();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::SnapshotField(*dynamic_cast<const ::CRYSTAL_NET::service::SnapshotField *>(coder));
    }

};

#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_com_5flibrary_2eproto
