// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_user_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_user_2eproto

// KERNEL_INCLUDED
#include <kernel/kernel.h>
#include <google/protobuf/util/json_util.h>
#include <google/protobuf/text_format.h>

#ifdef GetMessage
 #undef GetMessage
#endif


#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "com_user.pb.h"
#include "com_client_user.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_user_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_user_2eproto;
namespace CRYSTAL_NET {
namespace service {
class ModifyPwdInfo;
struct ModifyPwdInfoDefaultTypeInternal;
extern ModifyPwdInfoDefaultTypeInternal _ModifyPwdInfo_default_instance_;
class ModifyUserInfoReq;
struct ModifyUserInfoReqDefaultTypeInternal;
extern ModifyUserInfoReqDefaultTypeInternal _ModifyUserInfoReq_default_instance_;
class ModifyUserInfoRes;
struct ModifyUserInfoResDefaultTypeInternal;
extern ModifyUserInfoResDefaultTypeInternal _ModifyUserInfoRes_default_instance_;
class UserClientInfoNty;
struct UserClientInfoNtyDefaultTypeInternal;
extern UserClientInfoNtyDefaultTypeInternal _UserClientInfoNty_default_instance_;
}  // namespace service
}  // namespace CRYSTAL_NET
PROTOBUF_NAMESPACE_OPEN
template<> ::CRYSTAL_NET::service::ModifyPwdInfo* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::ModifyPwdInfo>(Arena*);
template<> ::CRYSTAL_NET::service::ModifyUserInfoReq* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::ModifyUserInfoReq>(Arena*);
template<> ::CRYSTAL_NET::service::ModifyUserInfoRes* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::ModifyUserInfoRes>(Arena*);
template<> ::CRYSTAL_NET::service::UserClientInfoNty* Arena::CreateMaybeMessage<::CRYSTAL_NET::service::UserClientInfoNty>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CRYSTAL_NET {
namespace service {

// ===================================================================

// AnnotaionInfo[opcode(37), nolog(false), XorEncrypt(false), KeyBase64(false), EnableStorage:(false)]
class UserClientInfoNty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.UserClientInfoNty) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message UserClientInfoNty failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message UserClientInfoNty failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message UserClientInfoNty failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message UserClientInfoNty failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message UserClientInfoNty failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftReadPos(ByteSizeLong());
    return true;
}

virtual bool Decode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message UserClientInfoNty failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftReadPos(ByteSizeLong());
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    auto attachStream = KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::NewThreadLocal_LibStream();
    attachStream->Attach(stream);
    auto ret = Decode(*attachStream);
    KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::DeleteThreadLocal_LibStream(attachStream);
    return ret;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    auto attachStream = KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::NewThreadLocal_LibStream();
    attachStream->Attach(stream);
    auto ret = Decode(*attachStream);
    KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::DeleteThreadLocal_LibStream(attachStream);
    return ret;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return false;
    }

    return true;
}


 public:
  inline UserClientInfoNty() : UserClientInfoNty(nullptr) {}
  ~UserClientInfoNty() override;
  explicit PROTOBUF_CONSTEXPR UserClientInfoNty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserClientInfoNty(const UserClientInfoNty& from);
  UserClientInfoNty(UserClientInfoNty&& from) noexcept
    : UserClientInfoNty() {
    *this = ::std::move(from);
  }

  inline UserClientInfoNty& operator=(const UserClientInfoNty& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserClientInfoNty& operator=(UserClientInfoNty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserClientInfoNty& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserClientInfoNty* internal_default_instance() {
    return reinterpret_cast<const UserClientInfoNty*>(
               &_UserClientInfoNty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserClientInfoNty& a, UserClientInfoNty& b) {
    a.Swap(&b);
  }
  inline void Swap(UserClientInfoNty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserClientInfoNty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserClientInfoNty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserClientInfoNty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserClientInfoNty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserClientInfoNty& from) {
    UserClientInfoNty::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserClientInfoNty* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.UserClientInfoNty";
  }
  protected:
  explicit UserClientInfoNty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientInfoFieldNumber = 1,
  };
  // .CRYSTAL_NET.service.ClientUserInfo ClientInfo = 1;
  bool has_clientinfo() const;
  private:
  bool _internal_has_clientinfo() const;
  public:
  void clear_clientinfo();
  const ::CRYSTAL_NET::service::ClientUserInfo& clientinfo() const;
  PROTOBUF_NODISCARD ::CRYSTAL_NET::service::ClientUserInfo* release_clientinfo();
  ::CRYSTAL_NET::service::ClientUserInfo* mutable_clientinfo();
  void set_allocated_clientinfo(::CRYSTAL_NET::service::ClientUserInfo* clientinfo);
  private:
  const ::CRYSTAL_NET::service::ClientUserInfo& _internal_clientinfo() const;
  ::CRYSTAL_NET::service::ClientUserInfo* _internal_mutable_clientinfo();
  public:
  void unsafe_arena_set_allocated_clientinfo(
      ::CRYSTAL_NET::service::ClientUserInfo* clientinfo);
  ::CRYSTAL_NET::service::ClientUserInfo* unsafe_arena_release_clientinfo();

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.UserClientInfoNty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CRYSTAL_NET::service::ClientUserInfo* clientinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(0), nolog(false), XorEncrypt(false), KeyBase64(false), EnableStorage:(false)]
class ModifyPwdInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.ModifyPwdInfo) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyPwdInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyPwdInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyPwdInfo failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyPwdInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message ModifyPwdInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftReadPos(ByteSizeLong());
    return true;
}

virtual bool Decode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message ModifyPwdInfo failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftReadPos(ByteSizeLong());
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    auto attachStream = KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::NewThreadLocal_LibStream();
    attachStream->Attach(stream);
    auto ret = Decode(*attachStream);
    KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::DeleteThreadLocal_LibStream(attachStream);
    return ret;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    auto attachStream = KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::NewThreadLocal_LibStream();
    attachStream->Attach(stream);
    auto ret = Decode(*attachStream);
    KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::DeleteThreadLocal_LibStream(attachStream);
    return ret;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return false;
    }

    return true;
}


 public:
  inline ModifyPwdInfo() : ModifyPwdInfo(nullptr) {}
  ~ModifyPwdInfo() override;
  explicit PROTOBUF_CONSTEXPR ModifyPwdInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyPwdInfo(const ModifyPwdInfo& from);
  ModifyPwdInfo(ModifyPwdInfo&& from) noexcept
    : ModifyPwdInfo() {
    *this = ::std::move(from);
  }

  inline ModifyPwdInfo& operator=(const ModifyPwdInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyPwdInfo& operator=(ModifyPwdInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyPwdInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyPwdInfo* internal_default_instance() {
    return reinterpret_cast<const ModifyPwdInfo*>(
               &_ModifyPwdInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ModifyPwdInfo& a, ModifyPwdInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyPwdInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyPwdInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyPwdInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyPwdInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyPwdInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyPwdInfo& from) {
    ModifyPwdInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyPwdInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.ModifyPwdInfo";
  }
  protected:
  explicit ModifyPwdInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldPwdFieldNumber = 1,
    kNewPwdFieldNumber = 2,
  };
  // string OldPwd = 1;
  void clear_oldpwd();
  const std::string& oldpwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oldpwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oldpwd();
  PROTOBUF_NODISCARD std::string* release_oldpwd();
  void set_allocated_oldpwd(std::string* oldpwd);
  private:
  const std::string& _internal_oldpwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldpwd(const std::string& value);
  std::string* _internal_mutable_oldpwd();
  public:

  // string NewPwd = 2;
  void clear_newpwd();
  const std::string& newpwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newpwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newpwd();
  PROTOBUF_NODISCARD std::string* release_newpwd();
  void set_allocated_newpwd(std::string* newpwd);
  private:
  const std::string& _internal_newpwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newpwd(const std::string& value);
  std::string* _internal_mutable_newpwd();
  public:

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.ModifyPwdInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oldpwd_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newpwd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(58), nolog(false), XorEncrypt(false), KeyBase64(false), EnableStorage:(false)]
class ModifyUserInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.ModifyUserInfoReq) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyUserInfoReq failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyUserInfoReq failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyUserInfoReq failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyUserInfoReq failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message ModifyUserInfoReq failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftReadPos(ByteSizeLong());
    return true;
}

virtual bool Decode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message ModifyUserInfoReq failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftReadPos(ByteSizeLong());
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    auto attachStream = KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::NewThreadLocal_LibStream();
    attachStream->Attach(stream);
    auto ret = Decode(*attachStream);
    KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::DeleteThreadLocal_LibStream(attachStream);
    return ret;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    auto attachStream = KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::NewThreadLocal_LibStream();
    attachStream->Attach(stream);
    auto ret = Decode(*attachStream);
    KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::DeleteThreadLocal_LibStream(attachStream);
    return ret;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return false;
    }

    return true;
}


 public:
  inline ModifyUserInfoReq() : ModifyUserInfoReq(nullptr) {}
  ~ModifyUserInfoReq() override;
  explicit PROTOBUF_CONSTEXPR ModifyUserInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyUserInfoReq(const ModifyUserInfoReq& from);
  ModifyUserInfoReq(ModifyUserInfoReq&& from) noexcept
    : ModifyUserInfoReq() {
    *this = ::std::move(from);
  }

  inline ModifyUserInfoReq& operator=(const ModifyUserInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyUserInfoReq& operator=(ModifyUserInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyUserInfoReq& default_instance() {
    return *internal_default_instance();
  }
  enum ModifyInfoCase {
    kPwdInfo = 1,
    kNickname = 2,
    MODIFYINFO_NOT_SET = 0,
  };

  static inline const ModifyUserInfoReq* internal_default_instance() {
    return reinterpret_cast<const ModifyUserInfoReq*>(
               &_ModifyUserInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ModifyUserInfoReq& a, ModifyUserInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyUserInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyUserInfoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyUserInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyUserInfoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyUserInfoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyUserInfoReq& from) {
    ModifyUserInfoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyUserInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.ModifyUserInfoReq";
  }
  protected:
  explicit ModifyUserInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPwdInfoFieldNumber = 1,
    kNicknameFieldNumber = 2,
  };
  // .CRYSTAL_NET.service.ModifyPwdInfo PwdInfo = 1;
  bool has_pwdinfo() const;
  private:
  bool _internal_has_pwdinfo() const;
  public:
  void clear_pwdinfo();
  const ::CRYSTAL_NET::service::ModifyPwdInfo& pwdinfo() const;
  PROTOBUF_NODISCARD ::CRYSTAL_NET::service::ModifyPwdInfo* release_pwdinfo();
  ::CRYSTAL_NET::service::ModifyPwdInfo* mutable_pwdinfo();
  void set_allocated_pwdinfo(::CRYSTAL_NET::service::ModifyPwdInfo* pwdinfo);
  private:
  const ::CRYSTAL_NET::service::ModifyPwdInfo& _internal_pwdinfo() const;
  ::CRYSTAL_NET::service::ModifyPwdInfo* _internal_mutable_pwdinfo();
  public:
  void unsafe_arena_set_allocated_pwdinfo(
      ::CRYSTAL_NET::service::ModifyPwdInfo* pwdinfo);
  ::CRYSTAL_NET::service::ModifyPwdInfo* unsafe_arena_release_pwdinfo();

  // bytes Nickname = 2;
  bool has_nickname() const;
  private:
  bool _internal_has_nickname() const;
  public:
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  void clear_ModifyInfo();
  ModifyInfoCase ModifyInfo_case() const;
  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.ModifyUserInfoReq)
 private:
  class _Internal;
  void set_has_pwdinfo();
  void set_has_nickname();

  inline bool has_ModifyInfo() const;
  inline void clear_has_ModifyInfo();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ModifyInfoUnion {
      constexpr ModifyInfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::CRYSTAL_NET::service::ModifyPwdInfo* pwdinfo_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    } ModifyInfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

// AnnotaionInfo[opcode(59), nolog(false), XorEncrypt(false), KeyBase64(false), EnableStorage:(false)]
class ModifyUserInfoRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRYSTAL_NET.service.ModifyUserInfoRes) */ , public KERNEL_NS::ICoder {
public:
virtual void Release() override {
    delete this;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyUserInfoRes failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyUserInfoRes failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Encode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) const override {
    if (UNLIKELY(!IsInitialized()))
    {
      g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyUserInfoRes failed, error: %s"), InitializationErrorString().c_str());
      return false;
    }

    size_t payloadSize = ByteSizeLong();
    if (payloadSize == 0)
      return true;

    if(UNLIKELY(stream.GetBuffer() == NULL))
        stream.Init(payloadSize);

    auto writableSize = stream.GetWritableSize();
    if (writableSize < static_cast<Int64>(payloadSize))
    {
        if(UNLIKELY(!stream.AppendCapacity(static_cast<Int64>(payloadSize) - writableSize)))
        {
            g_Log->Error(LOGFMT_OBJ_TAG("stream append capacity fail IsAttach:%d"), stream.IsAttach());
            return false;
        }
    }

    if (UNLIKELY(!SerializeToArray(stream.GetWriteBegin(), static_cast<Int32>(stream.GetWritableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Encode message ModifyUserInfoRes failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftWritePos(payloadSize);
    return true;
}

virtual bool Decode(KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message ModifyUserInfoRes failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftReadPos(ByteSizeLong());
    return true;
}

virtual bool Decode(KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    if (stream.GetReadableSize() == 0)
    {
        Clear();
        return true;
    }

    if (UNLIKELY(!ParseFromArray(stream.GetReadBegin(), static_cast<Int32>(stream.GetReadableSize()))))
    {
        g_Log->Error(LOGFMT_OBJ_TAG("Decode message ModifyUserInfoRes failed, error: %s"), InitializationErrorString().c_str());
        return false;
    }

    stream.ShiftReadPos(ByteSizeLong());
    return true;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::MT> &stream) override {
    auto attachStream = KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::NewThreadLocal_LibStream();
    attachStream->Attach(stream);
    auto ret = Decode(*attachStream);
    KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::DeleteThreadLocal_LibStream(attachStream);
    return ret;
}

virtual bool Decode(const KERNEL_NS::LibStream<KERNEL_NS::_Build::TL> &stream) override {
    auto attachStream = KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::NewThreadLocal_LibStream();
    attachStream->Attach(stream);
    auto ret = Decode(*attachStream);
    KERNEL_NS::LibStream<KERNEL_NS::_Build::TL>::DeleteThreadLocal_LibStream(attachStream);
    return ret;
}

virtual KERNEL_NS::LibString ToJsonString() const override {
    KERNEL_NS::LibString data;
    if(!::google::protobuf::util::MessageToJsonString(*this, &data.GetRaw()).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return "";
    }

    return data;
}

virtual bool ToJsonString(std::string *data) const override {
    if(!::google::protobuf::util::MessageToJsonString(*this, data).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("Turn JsonString fail:%s"), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return false;
    }

    return true;
}

virtual bool FromJsonString(const Byte8 *data, size_t len) override {
    auto &&jsonString = ::google::protobuf::StringPiece(data, len);
    if(!::google::protobuf::util::JsonStringToMessage(jsonString, this).ok())
    {
        g_Log->Warn(LOGFMT_OBJ_TAG("SimpleInfo field JsonStringToMessage fail jsonString:%s, message name:%s"), jsonString.as_string().c_str(), KERNEL_NS::RttiUtil::GetByObj(this).c_str());
        return false;
    }

    return true;
}


 public:
  inline ModifyUserInfoRes() : ModifyUserInfoRes(nullptr) {}
  ~ModifyUserInfoRes() override;
  explicit PROTOBUF_CONSTEXPR ModifyUserInfoRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyUserInfoRes(const ModifyUserInfoRes& from);
  ModifyUserInfoRes(ModifyUserInfoRes&& from) noexcept
    : ModifyUserInfoRes() {
    *this = ::std::move(from);
  }

  inline ModifyUserInfoRes& operator=(const ModifyUserInfoRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyUserInfoRes& operator=(ModifyUserInfoRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyUserInfoRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyUserInfoRes* internal_default_instance() {
    return reinterpret_cast<const ModifyUserInfoRes*>(
               &_ModifyUserInfoRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ModifyUserInfoRes& a, ModifyUserInfoRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyUserInfoRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyUserInfoRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyUserInfoRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyUserInfoRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyUserInfoRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyUserInfoRes& from) {
    ModifyUserInfoRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyUserInfoRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRYSTAL_NET.service.ModifyUserInfoRes";
  }
  protected:
  explicit ModifyUserInfoRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrCodeFieldNumber = 1,
  };
  // sint32 ErrCode = 1;
  void clear_errcode();
  int32_t errcode() const;
  void set_errcode(int32_t value);
  private:
  int32_t _internal_errcode() const;
  void _internal_set_errcode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CRYSTAL_NET.service.ModifyUserInfoRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t errcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserClientInfoNty

// .CRYSTAL_NET.service.ClientUserInfo ClientInfo = 1;
inline bool UserClientInfoNty::_internal_has_clientinfo() const {
  return this != internal_default_instance() && _impl_.clientinfo_ != nullptr;
}
inline bool UserClientInfoNty::has_clientinfo() const {
  return _internal_has_clientinfo();
}
inline const ::CRYSTAL_NET::service::ClientUserInfo& UserClientInfoNty::_internal_clientinfo() const {
  const ::CRYSTAL_NET::service::ClientUserInfo* p = _impl_.clientinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::CRYSTAL_NET::service::ClientUserInfo&>(
      ::CRYSTAL_NET::service::_ClientUserInfo_default_instance_);
}
inline const ::CRYSTAL_NET::service::ClientUserInfo& UserClientInfoNty::clientinfo() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.UserClientInfoNty.ClientInfo)
  return _internal_clientinfo();
}
inline void UserClientInfoNty::unsafe_arena_set_allocated_clientinfo(
    ::CRYSTAL_NET::service::ClientUserInfo* clientinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clientinfo_);
  }
  _impl_.clientinfo_ = clientinfo;
  if (clientinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRYSTAL_NET.service.UserClientInfoNty.ClientInfo)
}
inline ::CRYSTAL_NET::service::ClientUserInfo* UserClientInfoNty::release_clientinfo() {
  
  ::CRYSTAL_NET::service::ClientUserInfo* temp = _impl_.clientinfo_;
  _impl_.clientinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CRYSTAL_NET::service::ClientUserInfo* UserClientInfoNty::unsafe_arena_release_clientinfo() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.UserClientInfoNty.ClientInfo)
  
  ::CRYSTAL_NET::service::ClientUserInfo* temp = _impl_.clientinfo_;
  _impl_.clientinfo_ = nullptr;
  return temp;
}
inline ::CRYSTAL_NET::service::ClientUserInfo* UserClientInfoNty::_internal_mutable_clientinfo() {
  
  if (_impl_.clientinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::CRYSTAL_NET::service::ClientUserInfo>(GetArenaForAllocation());
    _impl_.clientinfo_ = p;
  }
  return _impl_.clientinfo_;
}
inline ::CRYSTAL_NET::service::ClientUserInfo* UserClientInfoNty::mutable_clientinfo() {
  ::CRYSTAL_NET::service::ClientUserInfo* _msg = _internal_mutable_clientinfo();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.UserClientInfoNty.ClientInfo)
  return _msg;
}
inline void UserClientInfoNty::set_allocated_clientinfo(::CRYSTAL_NET::service::ClientUserInfo* clientinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clientinfo_);
  }
  if (clientinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clientinfo));
    if (message_arena != submessage_arena) {
      clientinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clientinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clientinfo_ = clientinfo;
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.UserClientInfoNty.ClientInfo)
}

// -------------------------------------------------------------------

// ModifyPwdInfo

// string OldPwd = 1;
inline void ModifyPwdInfo::clear_oldpwd() {
  _impl_.oldpwd_.ClearToEmpty();
}
inline const std::string& ModifyPwdInfo::oldpwd() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.ModifyPwdInfo.OldPwd)
  return _internal_oldpwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModifyPwdInfo::set_oldpwd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.oldpwd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.ModifyPwdInfo.OldPwd)
}
inline std::string* ModifyPwdInfo::mutable_oldpwd() {
  std::string* _s = _internal_mutable_oldpwd();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.ModifyPwdInfo.OldPwd)
  return _s;
}
inline const std::string& ModifyPwdInfo::_internal_oldpwd() const {
  return _impl_.oldpwd_.Get();
}
inline void ModifyPwdInfo::_internal_set_oldpwd(const std::string& value) {
  
  _impl_.oldpwd_.Set(value, GetArenaForAllocation());
}
inline std::string* ModifyPwdInfo::_internal_mutable_oldpwd() {
  
  return _impl_.oldpwd_.Mutable(GetArenaForAllocation());
}
inline std::string* ModifyPwdInfo::release_oldpwd() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.ModifyPwdInfo.OldPwd)
  return _impl_.oldpwd_.Release();
}
inline void ModifyPwdInfo::set_allocated_oldpwd(std::string* oldpwd) {
  if (oldpwd != nullptr) {
    
  } else {
    
  }
  _impl_.oldpwd_.SetAllocated(oldpwd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.oldpwd_.IsDefault()) {
    _impl_.oldpwd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.ModifyPwdInfo.OldPwd)
}

// string NewPwd = 2;
inline void ModifyPwdInfo::clear_newpwd() {
  _impl_.newpwd_.ClearToEmpty();
}
inline const std::string& ModifyPwdInfo::newpwd() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.ModifyPwdInfo.NewPwd)
  return _internal_newpwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModifyPwdInfo::set_newpwd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newpwd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.ModifyPwdInfo.NewPwd)
}
inline std::string* ModifyPwdInfo::mutable_newpwd() {
  std::string* _s = _internal_mutable_newpwd();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.ModifyPwdInfo.NewPwd)
  return _s;
}
inline const std::string& ModifyPwdInfo::_internal_newpwd() const {
  return _impl_.newpwd_.Get();
}
inline void ModifyPwdInfo::_internal_set_newpwd(const std::string& value) {
  
  _impl_.newpwd_.Set(value, GetArenaForAllocation());
}
inline std::string* ModifyPwdInfo::_internal_mutable_newpwd() {
  
  return _impl_.newpwd_.Mutable(GetArenaForAllocation());
}
inline std::string* ModifyPwdInfo::release_newpwd() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.ModifyPwdInfo.NewPwd)
  return _impl_.newpwd_.Release();
}
inline void ModifyPwdInfo::set_allocated_newpwd(std::string* newpwd) {
  if (newpwd != nullptr) {
    
  } else {
    
  }
  _impl_.newpwd_.SetAllocated(newpwd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newpwd_.IsDefault()) {
    _impl_.newpwd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.ModifyPwdInfo.NewPwd)
}

// -------------------------------------------------------------------

// ModifyUserInfoReq

// .CRYSTAL_NET.service.ModifyPwdInfo PwdInfo = 1;
inline bool ModifyUserInfoReq::_internal_has_pwdinfo() const {
  return ModifyInfo_case() == kPwdInfo;
}
inline bool ModifyUserInfoReq::has_pwdinfo() const {
  return _internal_has_pwdinfo();
}
inline void ModifyUserInfoReq::set_has_pwdinfo() {
  _impl_._oneof_case_[0] = kPwdInfo;
}
inline void ModifyUserInfoReq::clear_pwdinfo() {
  if (_internal_has_pwdinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ModifyInfo_.pwdinfo_;
    }
    clear_has_ModifyInfo();
  }
}
inline ::CRYSTAL_NET::service::ModifyPwdInfo* ModifyUserInfoReq::release_pwdinfo() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.ModifyUserInfoReq.PwdInfo)
  if (_internal_has_pwdinfo()) {
    clear_has_ModifyInfo();
    ::CRYSTAL_NET::service::ModifyPwdInfo* temp = _impl_.ModifyInfo_.pwdinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ModifyInfo_.pwdinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CRYSTAL_NET::service::ModifyPwdInfo& ModifyUserInfoReq::_internal_pwdinfo() const {
  return _internal_has_pwdinfo()
      ? *_impl_.ModifyInfo_.pwdinfo_
      : reinterpret_cast< ::CRYSTAL_NET::service::ModifyPwdInfo&>(::CRYSTAL_NET::service::_ModifyPwdInfo_default_instance_);
}
inline const ::CRYSTAL_NET::service::ModifyPwdInfo& ModifyUserInfoReq::pwdinfo() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.ModifyUserInfoReq.PwdInfo)
  return _internal_pwdinfo();
}
inline ::CRYSTAL_NET::service::ModifyPwdInfo* ModifyUserInfoReq::unsafe_arena_release_pwdinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRYSTAL_NET.service.ModifyUserInfoReq.PwdInfo)
  if (_internal_has_pwdinfo()) {
    clear_has_ModifyInfo();
    ::CRYSTAL_NET::service::ModifyPwdInfo* temp = _impl_.ModifyInfo_.pwdinfo_;
    _impl_.ModifyInfo_.pwdinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModifyUserInfoReq::unsafe_arena_set_allocated_pwdinfo(::CRYSTAL_NET::service::ModifyPwdInfo* pwdinfo) {
  clear_ModifyInfo();
  if (pwdinfo) {
    set_has_pwdinfo();
    _impl_.ModifyInfo_.pwdinfo_ = pwdinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRYSTAL_NET.service.ModifyUserInfoReq.PwdInfo)
}
inline ::CRYSTAL_NET::service::ModifyPwdInfo* ModifyUserInfoReq::_internal_mutable_pwdinfo() {
  if (!_internal_has_pwdinfo()) {
    clear_ModifyInfo();
    set_has_pwdinfo();
    _impl_.ModifyInfo_.pwdinfo_ = CreateMaybeMessage< ::CRYSTAL_NET::service::ModifyPwdInfo >(GetArenaForAllocation());
  }
  return _impl_.ModifyInfo_.pwdinfo_;
}
inline ::CRYSTAL_NET::service::ModifyPwdInfo* ModifyUserInfoReq::mutable_pwdinfo() {
  ::CRYSTAL_NET::service::ModifyPwdInfo* _msg = _internal_mutable_pwdinfo();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.ModifyUserInfoReq.PwdInfo)
  return _msg;
}

// bytes Nickname = 2;
inline bool ModifyUserInfoReq::_internal_has_nickname() const {
  return ModifyInfo_case() == kNickname;
}
inline bool ModifyUserInfoReq::has_nickname() const {
  return _internal_has_nickname();
}
inline void ModifyUserInfoReq::set_has_nickname() {
  _impl_._oneof_case_[0] = kNickname;
}
inline void ModifyUserInfoReq::clear_nickname() {
  if (_internal_has_nickname()) {
    _impl_.ModifyInfo_.nickname_.Destroy();
    clear_has_ModifyInfo();
  }
}
inline const std::string& ModifyUserInfoReq::nickname() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.ModifyUserInfoReq.Nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline void ModifyUserInfoReq::set_nickname(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_nickname()) {
    clear_ModifyInfo();
    set_has_nickname();
    _impl_.ModifyInfo_.nickname_.InitDefault();
  }
  _impl_.ModifyInfo_.nickname_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.ModifyUserInfoReq.Nickname)
}
inline std::string* ModifyUserInfoReq::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:CRYSTAL_NET.service.ModifyUserInfoReq.Nickname)
  return _s;
}
inline const std::string& ModifyUserInfoReq::_internal_nickname() const {
  if (_internal_has_nickname()) {
    return _impl_.ModifyInfo_.nickname_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ModifyUserInfoReq::_internal_set_nickname(const std::string& value) {
  if (!_internal_has_nickname()) {
    clear_ModifyInfo();
    set_has_nickname();
    _impl_.ModifyInfo_.nickname_.InitDefault();
  }
  _impl_.ModifyInfo_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* ModifyUserInfoReq::_internal_mutable_nickname() {
  if (!_internal_has_nickname()) {
    clear_ModifyInfo();
    set_has_nickname();
    _impl_.ModifyInfo_.nickname_.InitDefault();
  }
  return _impl_.ModifyInfo_.nickname_.Mutable(      GetArenaForAllocation());
}
inline std::string* ModifyUserInfoReq::release_nickname() {
  // @@protoc_insertion_point(field_release:CRYSTAL_NET.service.ModifyUserInfoReq.Nickname)
  if (_internal_has_nickname()) {
    clear_has_ModifyInfo();
    return _impl_.ModifyInfo_.nickname_.Release();
  } else {
    return nullptr;
  }
}
inline void ModifyUserInfoReq::set_allocated_nickname(std::string* nickname) {
  if (has_ModifyInfo()) {
    clear_ModifyInfo();
  }
  if (nickname != nullptr) {
    set_has_nickname();
    _impl_.ModifyInfo_.nickname_.InitAllocated(nickname, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:CRYSTAL_NET.service.ModifyUserInfoReq.Nickname)
}

inline bool ModifyUserInfoReq::has_ModifyInfo() const {
  return ModifyInfo_case() != MODIFYINFO_NOT_SET;
}
inline void ModifyUserInfoReq::clear_has_ModifyInfo() {
  _impl_._oneof_case_[0] = MODIFYINFO_NOT_SET;
}
inline ModifyUserInfoReq::ModifyInfoCase ModifyUserInfoReq::ModifyInfo_case() const {
  return ModifyUserInfoReq::ModifyInfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ModifyUserInfoRes

// sint32 ErrCode = 1;
inline void ModifyUserInfoRes::clear_errcode() {
  _impl_.errcode_ = 0;
}
inline int32_t ModifyUserInfoRes::_internal_errcode() const {
  return _impl_.errcode_;
}
inline int32_t ModifyUserInfoRes::errcode() const {
  // @@protoc_insertion_point(field_get:CRYSTAL_NET.service.ModifyUserInfoRes.ErrCode)
  return _internal_errcode();
}
inline void ModifyUserInfoRes::_internal_set_errcode(int32_t value) {
  
  _impl_.errcode_ = value;
}
inline void ModifyUserInfoRes::set_errcode(int32_t value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:CRYSTAL_NET.service.ModifyUserInfoRes.ErrCode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service
}  // namespace CRYSTAL_NET

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>

class UserClientInfoNtyFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, UserClientInfoNtyFactory);
public:

    virtual void Release() override {
        UserClientInfoNtyFactory::Delete_UserClientInfoNtyFactory(this);
    }

    static UserClientInfoNtyFactory *CreateFactory() {
        return UserClientInfoNtyFactory::New_UserClientInfoNtyFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::UserClientInfoNty();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::UserClientInfoNty(*dynamic_cast<const ::CRYSTAL_NET::service::UserClientInfoNty *>(coder));
    }

};


class ModifyPwdInfoFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, ModifyPwdInfoFactory);
public:

    virtual void Release() override {
        ModifyPwdInfoFactory::Delete_ModifyPwdInfoFactory(this);
    }

    static ModifyPwdInfoFactory *CreateFactory() {
        return ModifyPwdInfoFactory::New_ModifyPwdInfoFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::ModifyPwdInfo();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::ModifyPwdInfo(*dynamic_cast<const ::CRYSTAL_NET::service::ModifyPwdInfo *>(coder));
    }

};


class ModifyUserInfoReqFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, ModifyUserInfoReqFactory);
public:

    virtual void Release() override {
        ModifyUserInfoReqFactory::Delete_ModifyUserInfoReqFactory(this);
    }

    static ModifyUserInfoReqFactory *CreateFactory() {
        return ModifyUserInfoReqFactory::New_ModifyUserInfoReqFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::ModifyUserInfoReq();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::ModifyUserInfoReq(*dynamic_cast<const ::CRYSTAL_NET::service::ModifyUserInfoReq *>(coder));
    }

};


class ModifyUserInfoResFactory : public KERNEL_NS::ICoderFactory {
    POOL_CREATE_OBJ_DEFAULT_P1(ICoderFactory, ModifyUserInfoResFactory);
public:

    virtual void Release() override {
        ModifyUserInfoResFactory::Delete_ModifyUserInfoResFactory(this);
    }

    static ModifyUserInfoResFactory *CreateFactory() {
        return ModifyUserInfoResFactory::New_ModifyUserInfoResFactory();
    }

    virtual KERNEL_NS::ICoder *Create() const override {
        return new ::CRYSTAL_NET::service::ModifyUserInfoRes();
    }

    virtual KERNEL_NS::ICoder *Create(const KERNEL_NS::ICoder *coder) const override {
        return new ::CRYSTAL_NET::service::ModifyUserInfoRes(*dynamic_cast<const ::CRYSTAL_NET::service::ModifyUserInfoRes *>(coder));
    }

};

#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_user_2eproto
