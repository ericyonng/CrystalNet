* 符号隔离
* 编译速度
* 符号隔离：可以通过把符号定义在类中，因为编译时类型是不可重复的，而且作为设计者类即模块，要保证模块的独立性，从设计层面上解决了符号隔离问题，否则归咎于设计问题
* 如果类型上无法保证符号隔离，比如多个系统有相同的模块，那么可以使用命名空间来隔离

![img](.\module1-2.png)

![img](.\module1-1.png)

* Module要解决的是符号可见性问题，替代头文件的一些使用场景（现代编程的模块化场景，解决模块之间的可见性控制问题，不解决模块之间的符号名称隔离问题）

* import 导入头文件，import导入的符号只对本编译单元可见, 不对其他编译单元可见，如果要将导入的符号对其他编译单元也可见，需要这样：export import b;(将导入的符号再次导出)，因为模块系统是为了严格规范符号可见性，

* 模块：模块接口单元（类似头文件用于导出符号），接口单元模块实现单元（编译单元，cpp等）

* 模块单元无法使用#include导入头文件，必须使用import

* 通过 import 导入头文件的编译单元定义的预处理宏，是无法被 import 导入的文件访问的，

  * ```
    import "h1.h"
    import "h2.h"
    如果h2中使用了h1中的宏，那么访问不到这个宏，因为模块之间的预处理宏不可见
    再比如：
    #ifndef __MODULE_B_
    如果h2中要访问__MODULE_B_也访问不到，除非__MODULE_B_被定义在全局模块片段
    
    ```

* 模块片段：全局模块片段和私有模块片段

* export 命名空间会把命名空间的内部都对外可见

* c++ module 在二进制分发有缺陷, 只能在各自的二进制库中使用不能跨二进制库使用

* module 各个编译期的实现情况

  * ![img](.\module1-3.png)