* 符号隔离
* 编译速度
* 符号隔离：可以通过把符号定义在类中，因为编译时类型是不可重复的，而且作为设计者类即模块，要保证模块的独立性，从设计层面上解决了符号隔离问题，否则归咎于设计问题
* 如果类型上无法保证符号隔离，比如多个系统有相同的模块，那么可以使用命名空间来隔离

![img](.\module1-2.png)

![img](.\module1-1.png)

* Module要解决的是符号可见性问题，替代头文件的一些使用场景（现代编程的模块化场景，解决模块之间的可见性控制问题，不解决模块之间的符号名称隔离问题）

* import 导入头文件，import导入的符号只对本编译单元可见, 不对其他编译单元可见，如果要将导入的符号对其他编译单元也可见，需要这样：export import b;(将导入的符号再次导出)，因为模块系统是为了严格规范符号可见性，

* 模块：模块接口单元（类似头文件用于导出符号），接口单元模块实现单元（编译单元，cpp等）

* 模块单元无法使用#include导入头文件，必须使用import

* 通过 import 导入头文件的编译单元定义的预处理宏，是无法被 import 导入的文件访问的，

  * ```
    import "h1.h"
    import "h2.h"
    如果h2中使用了h1中的宏，那么访问不到这个宏，因为模块之间的预处理宏不可见
    再比如：
    #ifndef __MODULE_B_
    如果h2中要访问__MODULE_B_也访问不到，除非__MODULE_B_被定义在全局模块片段
    
    ```

* 模块片段：全局模块片段和私有模块片段

* export 命名空间会把命名空间的内部都对外可见

* c++ module 在二进制分发有缺陷, 只能在各自的二进制库中使用不能跨二进制库使用

* module 各个编译期的实现情况

  * ![img](.\module1-3.png)

# 问题

1. A模块的全局模块单元中#include "b.h", c模块导入a 模块 import a;, 此时b.h仅在编译a模块的时候会展开，c模块导入a模块时只导入a公开的内容，不会再次对b.h进行展开，这就加快了编译速度

   ```
   在C++20模块系统中，#include 指令的行为与在传统C++项目中有所不同，特别是在处理头文件（header files）和模块（modules）之间的交互时。然而，你的问题涉及到几个关键点，这些点需要根据C++20模块系统的设计和实现来仔细考虑。
   
   首先，需要明确的是，C++20模块系统旨在解决传统C++中头文件包含（#include）带来的问题，如编译时间长、依赖关系复杂和头文件保护符（header guards）的维护等。在模块系统中，模块接口（.ixx、.cppm 或其他扩展名，取决于编译器）声明了模块的公共接口，而模块实现（.cpp 或其他实现文件）则包含了实现细节。
   
   现在，针对你的问题：
   
   全局模块单元：在C++20模块的标准术语中，并没有直接称为“全局模块单元”的概念。我假设你指的是模块接口或实现文件中的全局作用域。
   #include "b.h"：在模块接口或实现文件中使用#include指令来包含传统头文件是可能的，但这通常不是推荐的做法，因为这会引入传统头文件系统的复杂性和潜在问题。然而，为了与现有代码库兼容，编译器可能会支持这种做法。
   模块导入时的行为：当C模块（我们假设它也是一个C++20模块）通过import a;导入A模块时，编译器会处理A模块的接口部分，并查找该接口中声明的所有公开符号。然而，关于A模块接口中通过#include指令包含的头文件b.h，情况会有些不同：
   编译时行为：编译器在处理A模块的接口时，会展开#include "b.h"指令，并将b.h中的内容视为A模块接口的一部分（但这并不意味着b.h中的内容会自动对C模块可见）。然而，这种展开是发生在编译A模块接口时的，而不是在C模块导入A模块时。
   可见性和依赖关系：如果b.h中的任何符号（如类型、函数、类等）在A模块的接口中被引用，并且这些符号被标记为公开的（即，它们通过某种方式在A模块的接口中声明或导出），那么这些符号才会对C模块可见。否则，b.h中的内容将仅限于A模块的内部使用。
   编译时间和效率：虽然#include "b.h"在A模块接口中被展开，但这并不会导致在C模块导入A模块时再次展开。相反，A模块的接口（包括通过#include指令包含的内容）在编译时只会被处理一次，并生成相应的模块元数据，这些元数据随后会被用于C模块的编译过程中。
   综上所述，当C模块导入A模块时，A模块接口中通过#include指令包含的头文件b.h不会被再次展开。然而，b.h中的内容可能会对A模块的接口和实现产生影响，进而影响C模块对A模块的使用。为了确保代码的清晰性和可维护性，建议尽可能避免在模块接口中使用#include指令来包含传统头文件。
   ```

   

2. 