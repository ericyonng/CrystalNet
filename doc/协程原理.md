## 协程原理

## 开源: 

https://github.com/netcan/asyncio

#### 概念

* 等待器与可等待体
  * 等待器即：实现了await_resume、await_ready和await_suspen这3个成员函数的对象被称为等待器
  * 可以被等待的对象被称作可等待体
  * 比如如果std::string 重载了co_await操作符则它也变成了可等待体，但是它没有实现等待器的三个方法
* 协程概念
  * 协程是一个可恢复的函数，它比函数多了挂起和恢复的两个动作，函数锁占用的空间也被称作栈帧，一个协程被挂起它的状态必须被保存，一个协程帧不能简单用栈内存表达，它需要借助其他内存来保存这些状态，如堆内存
  * 一个协程调用，这个过程会创建协程的控制块，也被称做coroutine_handle, 它包含用户自定义的协程数据promise_type, 协程实参，当前保存的局部变量，以及协程内部的状态如挂起点灯，这些数据通常存放在内存上，协程创建完成后便返回给它的调用者
  * 得到协程句柄后，它可以被传递到其他地方例如产生一个普通的函数调用，并传递给它进行后续协程恢复动作
  * 协程恢复过程，恢复者调用协程句柄的resume函数它是一个普通的函数调用，并且控制流会转交给协程
  * 只要函数中存在co_await, co_yield, co_return它就会被当做协程处理
  * co_await, co_yield会挂起协程并把控制流返回给它的调用者，co_return 协程的返回动作，到这里协程的生命周期结束，它按照相反顺序销毁局部变量，并将控制流返回给它的调用者，后续只能销毁协程
  * 所以由于协程会挂起当前函数，函数中的局部变量会被保存到协程帧中，所以需要开发者明确局部变量的生命周期，确保在协程co_return 返回之前局部变量还没销毁（使用智能指针解决）
  * 调用者通过协程句柄的destroy()销毁一个协程并释放它的内存
  * 协程两个重要概念：Promise， Awaitable
    * Promise类型能够让用户定制一个协程的调用，返回行为，以及协程体内的co_await和co_yield表达式行为
    * Awaitable类型能够让用户定制co_await表达式语义，co_await 接受一个Awaitable对象，该对象能够控制当前协程是否挂起，挂起后需要执行哪些逻辑供将来恢复，以及恢复后如何产生该表达式的值
  * c++20协程是无栈协程，对于有栈协程占用内存更少，有更强的性能，无栈协程只能在协程中挂起协程，不能在普通函数挂起协程，因为五站协程不会保存协程的调用栈，有栈协程会保存整个调用栈，不过无栈协程可以通过子协程获得并存储父协程的句柄来恢复父协程，形成父子关系的链表，通过对整个链表进行遍历可挖掘整个协程调用栈，中间不会记录普通函数，因为没必要，普通函数只是一个短暂的瞬间，如果普通函数要挂起，那么它应该写成协程的形式
  * co_yield 是让出控制权，yield会接受一个值，表明它将让出控制权，并把值传递给调用者，常用在生成器中，生成器是一种协程，它复杂产生一系列值，通常与普通函数协作，调用者需要一个值时便恢复生成器的控制权，整个过程生成器的状态将一直被保留，控制流不断在*普通函数与协程之间切换*
  * co_await更多在协程和协程之间的协作上，当父协程await子协程时，表明它将让出控制权，交给子协程处理，子协程完成了处理并返回结果后，控制权将返回给父协程继续处理，await也被称为异步等待，
  * ![得到App_2024-02-29_15-10-39](.\coroutine_img\得到App_2024-02-29_15-10-39.png)

#### 原理分析

* bool await_ready() const 返回true, 表明目标对象准备好了， 也就是说协程无需在此挂起，执行流会继续按照代码编写顺序同步执行后续代码，这种情况下await_suspend会被忽略，直接执行await_resume,如果函数返回false，则表示对象没准备好需要执行后续操作
* 所谓后续操作即调用await_suspend(std::experimental:: coroutine_handle <>h)函数，*coroutine_handle<>是协程的句柄，用于控制协程的运行流程*， 它是由编译器生成，它包含协程挂起和恢复的上下文信息，coroutine_handle<>有operator()和resume()函数，它们可以执行挂起点之后的代码，await_suspend, 返回值：
  * void 表示协程需要将执行流控制权交给调用者，协程保持挂起状态,
    * 例如 co_await awaitable_expr; do_next(); 执行完awaitable_expr协程挂起，如果返回值是void， 此时不会执行下文的do_next, 而是直接在调用处返回
  * 返回bool类型：true时，效果和void一样协程挂起，当返回false时，则恢复当前协程运行（执行下文），
  * 返回coroutine_handle类型时，则会恢复句柄对应的协程
  * 如果在await_suspend中抛异常那么就会传递到最顶层的协程抛异常，而且协程会恢复执行（如果在执行协程任务的时候抛异常，会唤醒这个协程并继续执行）
* await_resume  与恢复无关，只是返回最终结果

## co_await 表达式与Awaitable

* 用户可以通过Awaitable定制co_await表达式语义，编译器会对co_await expr表达式中的expr进行两步转换，以便得到最终的Awaiter类型，并依赖它生成一些控制代码
  * 首先用户定义的Promise对象是否存在成员函数await_transform, 如果存在则令Awaitable对象为await_transform(expr), 如果不存在则令Awaitable对象为expr， 这一步让协程有控制co_await表达式行为的能力
  * 经过上一步得到Awaitable对象后，检查该对象是否重载了operator co_await()操作符，如果重载则使用该函数调用后的结果作为最终Awaiter对象，否则直接作为Awaiter对象
  * 上两步是编译时多态
  * co_await 执行流：

![得到App_2024-02-29_17-25-21](.\coroutine_img\得到App_2024-02-29_17-25-21.png)

## 协程生命周期注意

* 协程创建时会通过拷贝，拷贝实参和局部变量到堆内存，如果是值传递的实参会通过移动构造拷贝，如果是引用传递，会引用该对象，当任何阶段发生异常就会析构这些拷贝的对象，需要注意重复释放问题，实参对于大对象尽量使用引用，对于简单的值可使用值传递，注意对象的生命周期

## Promise<T> 与Future<T>关系

Promise描述一个未知的值，Future来获取将来的值

Promise用来存储待提供的值，定制协程调用，返回值行为，以及co_await和co_yield行为

协程是一个可恢复的函数，除了它的函数体需要至少co_return, co_aait,co_yield中一个以外，返回类型Future（协程返回值类型视作Future）还要求提供对应的Promise类型

![得到App_2024-02-29_17-35-41](.\coroutine_img\得到App_2024-02-29_17-35-41.png)

## 协程句柄，协程帧内存结构

* 它存储了协程恢复、销毁两个函数指针，以及协程实参，内部状态，还有保存局部变量，其中promise_type需要用户实现，它需要满足Promise概念，coroutine_handler封装了协程帧的指针，并提供恢复协程，销毁协程，以及获取协程Promise类型等接口，done接口可以判断协程是否处于结束状态
* 协程句柄来源：c++编译器会对协程代码进行变换，插入分配协程帧的代码
* 调用协程时，首先对协程帧进行动态内存分配，默认使用operator new分配，大小为编译时确定的协程帧所需的空间
* 为协程帧分配内存后，接着将调用者传递给协程的实参拷贝到协程帧中，以便后续协程挂起后仍能访问这些实参，如果实参是按值传递，那么它们会通过移动构造传递到协程帧中，如果协程实参是引用传递，那么它们仅将传递引用到协程帧中，注意：引用凡是传递实参如果是右值引用，如果接受的是临时变量，后续协程恢复后将导致非法内存访问，需要确保所有实参在协程恢复的时候都是有效的，除了注意直接使用右值外，还应注意完美转发，这种情况下这些右值可能会出现问题
* 如果在拷贝实参过程中抛出异常，那么已经拷贝过的实参将依次析构，并释放协程帧内存，将异常抛给它的调用者
* 完成实参的拷贝过程，接下来就是构造Promise对象，如果用户定义了Promise类的构造函数，并且构造函数参数与协程的参数类型，个数都一致，那么将会调用此构造函数，否则调用默认的构造函数，也就是说用户有机会再Promise构造函数中查看传递给协程的实参，从而控制协程的一些行为（泛型模板）
* 如果构造Promise对象过程中发生了异常，同样将依次析构实参，释放协程帧内存并抛回给它的调用者
* Promise构造完成后需要利用Promise来构造协程的返回类型Future对象，以便这个对象返回给它的调用者
* 协程传递: 协程帧 => Promise => Future => 调用者
  * ![得到App_2024-03-03_15-08-53](coroutine_img\得到App_2024-03-03_15-08-53.png)
* 协程代码变换
  * ![得到App_2024-03-03_15-03-35](coroutine_img\得到App_2024-03-03_15-03-35.png)

* initial_suspend一般返回suspend_always或suspend_never， 这个接口不能抛异常否则会出现双重释放的问题
* yield_value接口定制co_yield关键字行为，通过给Promise类实现yield_value接口，它仅仅是co_await的语法糖，在协程代码变换中，co_yield a变换成co_await promise.yield_value (a)调用，生成器通过这个接口产生一个值
* final_suspend挂起点：当协程体抛异常或通过co_return 返回时都将到达这个挂起点，例如将最终返回的结果传递给调用它的协程，并恢复调用它的协程，若用户从这个点挂起，则后续需手动通过句柄销毁协程，否则会自动销毁协程，后续如果通过句柄销毁则会出现双重释放问题，最好的方法是在这个点对协程进行挂起，交由程序员手动销毁。因为Future是一个RAII类，可由它析构时通过协程句柄销毁，该接口不能抛异常，所以是现实必须被修饰为noexcept，另外在这个点挂起后，协程句柄的done接口为真
* 销毁过程：
  * 析构Promise
  * 析构协程实参
  * 释放协程帧内存
  * 返回给协程调用者，恢复者
* 我们将生成器的Future命名为Generator，提供promise_type类型成员为Promise，Future由Promise提供（get_return_object）

## 协程与传统异步回调的比较

* 回调带来的后果是代码难以阅读，因为处理一个异步调用点的结果时，该结果被割裂在另一个回调函数中，而回调函数有可能发起另一个异步处理，形成回调地狱
* 协程带来的好处是以同步方式编写异步代码，每一个后续处理都位于co_await 表达式之后，听你刚刚co_await发起一个异步操作，这个异步操作结束后恢复此协程的执行，如此从co_await表达式得到的结果，从而进行后续的处理，整个过程中代码完全是结构化的，协程在与编程中提高了更高阶的抽象，而不是类似goto那种非结构化的代码，

#### 疑问

* await_ready 什么时候被调用？co_await时候被调用还是什么时候？
* await_suspend什么时候被调用

