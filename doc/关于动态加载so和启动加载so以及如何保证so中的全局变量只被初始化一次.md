在 Linux 下，如果可执行程序和通过 `dlopen` 动态加载的模块 B 都引用了同一个共享对象（模块 A），那么模块 A 中的全局变量是否会被初始化多次，取决于模块 A 的加载方式和符号的可见性。以下是详细分析：

---

### 1. **模块 A 被加载一次的情况**
如果模块 A 在可执行程序启动时已经被加载（例如通过可执行程序的依赖关系），并且模块 B 在 `dlopen` 时使用的是相同的模块 A，那么模块 A 的全局变量只会被初始化一次。

#### 具体过程：
- 可执行程序启动时，动态链接器会加载模块 A（如果它是可执行程序的依赖）。
- 当模块 B 通过 `dlopen` 加载时，如果模块 B 也依赖模块 A，动态链接器会复用已经加载的模块 A，而不会重新加载。
- 因此，模块 A 的全局变量只会被初始化一次。

#### 关键点：
- 模块 A 的加载是全局的，动态链接器会确保同一个共享对象在进程中只被加载一次。
- 模块 B 通过 `dlopen` 加载时，会使用已经加载的模块 A。

---

### 2. **模块 A 被加载多次的情况**
如果模块 A 在 `dlopen` 加载模块 B 时被显式地重新加载（例如通过 `dlopen` 的 `RTLD_LOCAL` 标志），那么模块 A 可能会被加载多次，导致全局变量被初始化多次。

#### 具体过程：
- 可执行程序启动时，模块 A 被加载一次。
- 当模块 B 通过 `dlopen` 加载时，如果使用了 `RTLD_LOCAL` 标志，并且模块 B 显式依赖模块 A，动态链接器可能会加载一个新的模块 A 实例。
- 这样，模块 A 的全局变量会被初始化两次：一次用于可执行程序，一次用于模块 B。

#### 关键点：
- 使用 `RTLD_LOCAL` 标志时，动态链接器可能会为模块 B 创建一个独立的模块 A 实例。
- 全局变量的初始化次数取决于模块 A 被加载的次数。

---

### 3. **如何确保模块 A 只被加载一次**
为了避免模块 A 被多次加载，可以采取以下措施：
- 在 `dlopen` 时使用 `RTLD_GLOBAL` 标志，确保模块 A 的符号全局可见，从而复用已经加载的模块 A。
- 确保模块 A 在可执行程序启动时已经被加载（例如通过可执行程序的依赖关系），这样 `dlopen` 时会自动复用。

#### 示例代码：
```c
void* handle = dlopen("moduleB.so", RTLD_NOW | RTLD_GLOBAL);
if (!handle) {
    fprintf(stderr, "Error loading module B: %s\n", dlerror());
    return 1;
}
```

---

### 4. **总结**
- 如果模块 A 在可执行程序启动时已经被加载，并且模块 B 通过 `dlopen` 加载时复用了模块 A，那么模块 A 的全局变量只会被初始化一次。
- 如果模块 A 被显式地重新加载（例如通过 `RTLD_LOCAL`），则全局变量可能会被初始化多次。
- 为了避免多次初始化，建议使用 `RTLD_GLOBAL` 标志，并确保模块 A 在可执行程序启动时已经被加载。

希望这能解答你的疑问！如果还有其他问题，欢迎继续讨论。