## 概念Concept

* 定义：它是一个对类型约束的编译期谓词，给定一个类型判断其能否满足语法和语义要求

* 用途：用来在编译期表达对类型的约束，例如：C<T> 的C是概念，T是类型，它表达：T满足C所有的要求，那么为真，否则为假（Concept返回是一个bool常量，可以配合static_assert来语法检查）

* 性能，它对编译期时间友好

* 语法

  * c++ 定义一个concept语法：

  * ```
    template<被约束的模版参数列表>
    concept 概念名 = 约束表达式;
    ```

  * 概念被定义为约束表达式，也可以简单理解成布尔常量表达式

  * 概念和模版using的别名很类似，前者是对布尔表达式的别名，后者是堆模版类型的别名

* 除了使用typetraits来定义概念外，requires表达式也提供了一种简明的方式来表达对模版参数及其对象的特征要求：成员函数，自由函数，关联类型等

* 

* （GCC在定义concept时不会报错，在求值时才进行类型检查，Clang在定义时就会进行类型检查）

## requires表达式

* requires表达式结果为bool类型，即编译时谓词，当对requires表达式进行求值时，按照表达式体中声明的先后顺序一次检查表达式的合法性，当遇到一条非法的表达式时，返回结果为不满足，与短路类似后续表达式也无须进一步检查，所有表达式都合法时，返回结果为满足（真）

* 可选的形参列表声明了一系列局部变量，这些局部变量不允许提供默认参数，他们对整个表达式体可见。这些变量没有链接性，存储性与生命周期，仅仅用作提出要求时的符号。如果在表达式体中引用了未声明的符号，视作语法错误。

* requires表达式提供了四种形式的要求：简单要求，类型要求，复合要求，嵌套要求

* 简单要求

  * 要求机器包含成员函数powerUp/powerDown:表达式体会对每一行表达式进行检查, 但是不会创建对象，所以不需要考虑指针或者引用等，

    * ```
      template<typename M>
      concept Machine = requires(M m){
      	m.powerUp();	// 是否存在成员函数powerUp
      	m.powerDown();	// 是否存在成员函数powerDown
      };
      ```

  * 判断是否含有自由函数playe, 静态成员count, 是否存在成员变量age：

    * ```
      template<typename T>
      concept Animal = requires(T animal){
      	play(animal);
      	T::count;
      	animal.age;	// 
      }
      ```

* 类型要求

* 